# 操作系统

## 引论

### 什么是操作系统

- 资源管理者
- 人机接口

### 多道批处理

#### 特点

- 多道：内存中有多道程序
- 宏观上并行：多道程序可以同时处于运行状态
- 微观上串行：各作业交替使用CPU

#### 优缺点

- 多道批处理系统的优缺点
- 源利用率高
- 系统吞吐量大
- 作业平均周转时间长
- ==无交互能力==

### 分时系统

#### 各系统的提升

- 多道批处理：提高了利用率和吞吐量
- 分时系统：良好的人机交互

#### 分时系统的实现

- 分时技术：把时间分为很短的时间切片
- 作业在时间片内未完成就中断，等待下一轮运行
- 每个用户都可以快速获得响应，实现人机交互
- 保存恢复现场需要而外的开销

#### 分时系统的特征

- 多路性：允许在一台主机上同时联接多台联机终端,系统按分时原则为每个用户服务。
- 独立性：每个用户各占一个终端,彼此独立操作,互不干扰。
- 及时性：用户的请求能在很短时间内获得响应
- 交互性：用户可通过终端与系统进行广泛的人机对话。

### 实时系统

- 对响应时间有严格限制
- 处理事物必须在特定时间限额（Deadline）内完成

### 系统调用

- 核心态：操作系统内核执行时的状态，有较高特权，能执行一切指令、访问所有寄存器和存储区（如软件调试）
- 用户态：用户程序运行时的状态，特权低，只能执行规定的指令、访问规定的寄存器和存储区

### 操作系统结构

#### C/S结构

- 宏内核：整个系统是一个大模块
- 微内核：把操作系统内非必要的功能尽可能的从内核分离出来，使内核简洁
- windows等为微内核
- linux为宏内核

C/S结构的优点（微内核）

- 良好的扩充性：支持添加新服务
- 可靠性好：服务器出错，不会导致整个系统瘫痪
- 便于网络服务，实现分布式
- 充分模块20化：可以单独更换单个模块
- 未使用模块不必运行：减少内存需求
- 较高的移植性：只需要把微内核本身进行移植就可以完成将整个内核移植到新的平台上。其他模块都只依赖于3微内核或其他模块,并不直接直接依赖硬件。

## 进程与线程

### 引言

- 程序：指令或语句**序列**
- 顺序环境：在计算机系统中只有一个程序在运行，这程序独占系统中所有资源，其执行不受外界影响

#### 程序顺序执行的特征

- 顺序性：处理机的操作严格按照程序所规定的顺序执行，只有当上一个操作完成后，下一操作才能开始执行。
- 封闭性：程序运行时独占全机资源，资源的状态（除初始状态外），只有本程序才能改变。
- 可再现性：在相同的初始条件下，一定会得到相同的结果

#### 并发与并行的异同

- 并行
  - 同一时间，有两个事物处于活动状态
- 并发
  - 宏观上并行，微观上顺序执行
  - 同一时刻只有一个事物处于活动状态
  - ![image-20200921170323364](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200921170323364.png)

#### 程序并发执行的特征

- 间断性
- 失去封闭性
- 不可再现性

### 进程

#### 为什么引入进程

- 为了程序能并发执行，且对并发执行的程序加以描述和控制

#### 什么是进程

- 定义：进程（process）是程序在一个数据集合上运行的过程，它是系统进行资源分配囗调度的一个独立单位
- 一个进程就是一个正在执行的程序，包括程序计数器、寄存器和变量的当前值。

#### 进程和程序的区别

- 进程是动态的（程序执行的过程），程序是静态的（代码的集合）
- 进程是暂时的，程序的永久的
- 进程是由程序、数据和进程控制块组成
- 一个程序可以有多个进程，一个进程也可以有多个程序
- 进程可以创建其他进程，程序不能创建新的程序

#### 进程的状态

![image-20200921172258919](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200921172258919.png)

- 就绪态：进程已获得除CPU以外的所以必要资源
- 执行态：获得CPU，正在CPU上执行
- 阻塞态：只有执行拥塞的事件后，才去竞争CPU，**在拥塞态下，就算获得CPU也无法执行**

#### 进程的实现

- 进程上下文：上下文是指进程运行的环境，包括程序计数器、堆栈指针、通用寄存器内容
- 上下文切换：CPU控制器由一个进程转换到另一个就绪进程的事件，上下文切换包括保存当前进程的运行环境，恢复将要运行进程的运行环境

##### 进程的组成

![image-20200925110455981](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200925110455981.png)

- Process Contro|Bock：进程存在的唯一标志。
- 程序：描述了进程要完成的功能是进程执行时不可修改的部分。
- 数据：进程执行时用到的数据（用户输入的数据、常量、静态变量）。
- 工作区：参数传递、系统调用时使用的动态区域（堆栈区）。

##### 进程控制块|PCB

- 作用是使一个在多道程序环境下不能运行的程序（含数据），成为一个能独立运行的基本单与其它进程并发执行的进程。

- 它记录了操作系统所需的用于描述进程的当前情况以及控制进程运行的全部信息
- 进程和PCB是一一对应

#### 进程控制块的信息

- 进程标识符：用于唯一的标识系统中的每个进程
- 处理机状态：用于CPU切换时保存与恢复现场
- 进程调度信息：用于进程调度和进程对换的相关信息
  - 进程状态
  - 进程优先级
  - 进程等待和使用CPU的时间总和
  - 阻塞原因
- 进程控制信息
  - 程序和数据的地址
  - 进程同步和通信信息
  - 资源清单
  - 进程队列和指针

#### 阻塞队列

![image-20200925112652474](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200925112652474.png)

<center>单阻塞队列</center>

- 只有单一队列，事件结束要遍历队列

![image-20200925112706916](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200925112706916.png)

<center>多阻塞队列</center>

- 不同的等待事件有不同的队列，提高效率

#### 进程控制块的组织方式

- 链接方式
  - ![image-20200925113805552](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200925113805552.png)
- 索引方式
  - ![image-20200925114726172](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200925114726172.png)

#### 进程的创建

- 

- 原语：不可再分的原子操作，不可被打断
- 

### 线程

#### 进程和线程区别

- 进程
  - 进程是一个可以拥有资源的基本单位
  - 进程同时是一个可独立调度和分派的基本单位
  - 进程需要系统创建进程、撤销进程和切换进程
  - 粒度大，并发度低
  - 时空开销大
  - 进程间通信代价高
- 线程
  - 把管理和执行分离
  - 相对独立、可调度的执行单位
  - 与进程内其他线程共享资源，不单独拥有资源，除了程序计数器、一组寄存器和栈
- 总结
  - 调度
  - 并发性
  - 拥有资源
  - 系统开销

#### 线程的结构

![image-20200928170802469](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200928170802469.png)

#### 线程的实现

- 用户级线程|ULT
  - ![image-20200928170838476](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200928170838476.png)
  - 内核不知道线程的存在，调度仍以进程为单位
  - 线程由应用自己的线程库维护
  - 线程切换不需要核心态特权
  - 优点
    - 不用调用核心
    - 调度方法可以自己特定
    - 可以运行在任何操作系统上
  - 缺点
    - 阻塞发生在进程级，进程内一个线程阻塞，整个线程都阻塞
    - 一个进程内的两个线程不能执行在两个处理器上
- 系统级线程|KLT
  - ![image-20200928170903077](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200928170903077.png)
  - 由核心完成，利用系统调用
  - 以线程为基础进行调度
  - 优点
    - 还可以同时调度一个进程的多个线程
    - 阻塞在线程级完成
  - 缺点
    - 线程切换调用内核效率下降
- 总结
  - 进程的调度和切换速度
  - 系统调用的阻塞
  - 进程执行的时间

### 进程间通信

#### 互斥

- 临界资源：一次仅允许一个进程访问的资源
- 临界区：每个进程中，访问临界资源的那段代码称为临界区

#### 同步

- 进程同步的主要任务是使并发执行的各进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。

#### 进程通信的解决原则

- 互斥原则：任何两个进程不能同时处于临界区
- 通用性原则：不应对CPU的速度和数目进行任何假设
- 有效性原则：临界区外的进程不应阻塞其他进程
- 合理性原则
  - 不得使进程在临界区外无限制的等待
  - 当进程无法进入临界区时,应放弃CPU资源

#### 轮转方法

##### 软件方法

###### 锁变量

```c++
//进程A
while(lock != 0);
lock = 1;
Critical_region();
lock=0;

//进程B
while(lock != 0);
lock = 1;
Critical_region();
lock=0;
```

![image-20201005170637825](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201005170637825.png)

- 缺陷
  - 仍然有竞争条件，不能解决互斥问题
  - **不具有操作的原子性**

###### 严格轮转法

```c++
//进程A
while(TRUE){
    while(turn != 0);
    Critical_region();
    turn = 1;//<==B进程被A进程阻塞
    Nocritical_region();
}

//进程B
while(TRUE){
    while(turn != 1);
    Critical_region();
    turn = 1;
    Nocritical_region();
}
```

- 缺陷
  - 忙等待浪费CPU时间
  - 违反**有效性原则**

###### Dekker算法

```c++
Pturn = FALSE;//进程P的意愿
Qturn = FALSE;//进程Q的意愿
enum turn;//当前应当进入的进程，值为1或2

//进程P
while(TRUE){
    Pturn = TRUE;
    while(Qturn){	//当Q进程有意愿的时候，进入循环
        if(turn == 2){	//当前进程不是P时，P进程退让
            Pturn = FALSE;
            while(turn == 2);
            Pturn = TRUE;
        }
    }
    Critical_region();
    turn = 2;	//进程轮转
    Pturn = FALSE;
}

//进程Q
while(TRUE){
    Qturn = TRUE;
    while(Pturn){
        if(turn == 2){
            Qturn = FALSE;
            while(turn == 2);
            Qturn = TRUE;
        }
    }
    Critical_region();
    turn = 1;
    Qturn = FALSE;
}
```

######  Peterson方法

```c++
void enter_region(int iProcessID){
    //另一个进程的ID
    int other;
    other = 1 - iProcessID;
    interested[iProcessID] = TRUE;
    //turn用来防止死锁
    turn = iProcessID;
    //turn==iProcessID，说明当前的进程是后来的，因为如果是新来的，则turn应该是前一个进程的ID
    //intersted[other]==true代表此时已有进程在等待或已经进入临界区，该进程等待
    while((turn == iProcessID)&&(interested[other] == TRUE));
}
void leave_region(int iProcessID){
    interested[iProcessID] = FALSE;
}
```

##### 硬件方法

###### 关中断

- 解决思想
  - 在临界区中防止发生进程调度
  - 保证临界区操作的完整性
- 方法分析
  - 用户控制系统中断是非常危险的
  - 对多个CPU系统将失去作业

###### TSL

- 锁变量法的问题：管理临界区标志要用两条指令，而在这两条指令间可能被中断
- 测试和上锁这两个动作不分开，保证只有一个进程进入临界区状态

```
TSL RX, LOCK
```

- 将内存单元LOCK都值宋儒寄存器RX中，将LOCK的值设为非0
- 执行TSL时，CPU将锁住内存总线，以禁止其它CPU在本指令结束之前访问内存。
- 硬件实现提高速度，同时适用于多处理机
- 依然存在忙等待问题

###### 忙等待模型汇总分析

- 优点
  - 实现简单易懂，可有效保证互斥
- 缺点
  - 只适用两个昵称互斥，不具有通用性
  - 忙等待严重浪费CPU资源，降低硬件效率
  - 优先级调度+忙等待=优先性反转
    - 进程H和L，H优先级比L优先级高
    - 先进入临界区，H后进入临界区
    - H开始忙等待，而L由于无法获得CPU也不能离开临界区

### 休眠与唤醒

#### 简单的睡眠-唤醒方法

- 操作系统原语设计
  - Sleep()：调用该原语的进程将变为阻塞态
  - Wakeup(ID)：该原语将唤醒ID标识的进程
- 原语使用思想
- 进入临界区前检查竞争条件，如不满足则睡眠
- 离开临界区后唤醒互斥进

```c++
//Producer进程
while(TRUE){
   Produce-Item();
   if(count == N)
      sleep();
   Enter-item();
   count = count + 1;
   if(count == 1)
       wakeup(consumer);
}
//Comsumer进程
while(TRUE){
    if(count == 0)
        sleep();
    Remove-Item();
    count = count - 1;
    if(count == N-1)
    	wakeup(producer);
    Consume-item();
}
```

![image-20201009113630251](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201009113630251.png)

#### 信号量机制

```c++
struct semaphore{
    int value;			//资源使用情况
    PCB *queue;		//信号量等待队列
}
/**
	*	value:
	*		>0： 表示系统中该类资源当前可用的数目,
	*		=0：表示资源已被占用，无其它进程等待
	*		<0：表示该类资源已分配完毕，其绝对值表示系统中因请求该类资源而阻塞在 queue队列上等待的进程数目
**/
```

- 除初始化外，仅能通过down()、Up()操作（P，V操作）来访问信号量。
- P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态，加入到等待队列。
- V(s)：将信号量s加1,若结果不大于0，则释放一个等待信号量s的进程。

##### 用信号量实现同步

​	**生产者每次生产一件物品（数据）存入缓沖区,消费者每次从缓冲区取一件物品消费。假定缓冲区只能存放一件物品。**

###### 只存在一个生产者和一个消费者的问题

- 如果只设置一个信号量，那只能对生产者或消费者中的一个进行制约
- 所以要双信号量：empty、full
- empty = 1 表示缓冲区为空，生产者可以存入缓冲区
- full = 1 表示缓冲区不为空，消费者可以取出缓冲区的东西
- 初始empty = 1，full = 0

```c++
semaphore empty,full;
empty.value = 1;
full.value =0;
//生产者
process producer{
    int data;
    produce();
    P(&empty);
    put();
    V(&full);
}
//消费者
process consumer{
    int data;
    P(&full);
    get();
    V(&empty);
}
```

###### 存在m个生产者和n个消费者

- 如果只用两个信号量，会导致多个进程在缓冲区中
- 引入互斥信号量mutex，初值为1

```c++
#define N 100
semaphore mutex, empty, full;
mutex.value = 1;
empty.value = N;
full. value = 0;
//生产者
process producer{
    int item;
    while(TRUE){
        Produce-Item(&item);
        down(&empty);
        down(&mutex);
        Enter-item(item);
        up(&mutex);
        up(&full);
    }
}
//消费者
process consumer{
    int item;
    while(TRUE){
        down(&full);
        down(&mutex);
        Remove-item(item);
        up(&mutex);
        up(&empty);
    }
}
```

- 如果颠倒mutex和full或empty，那么一个进程获取互斥后，如果无法获取full或empty，导致死锁
- 互斥信号量要紧靠着临界区，其它信号就相对临界区就在外一层

![image-20201010113913108](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201010113913108.png)

###### 同步、互斥信号量的使用方法

- 互斥信号量：必定成对出现：进入临界界区—退出临界区
- 同步信号量：未必成对出现,依赖于同步关系的性质
- 同步信号量和互斥信号量的操作顺序
  - 基本原则：**互斥信号量永远紧邻临界区**
- 优点分析
- 彻底解决忙等待弊端，提高OS的管理层次
  - 可实现复杂的同步与互斥情况，特别是多进程间通信
  - 可最大限度的保证并发效率
- 缺点分析
  - 实现机制复杂，互斥和同步关系分析困难
  - 存在死锁陷阱，需要谨慎小严密的设计

#### 管程方法

- 管程是一种集中式同步机制，它的基本思想是将共享变量以及对共享变量能够进行的所有操作集中在一个模块中。
- 任意时刻，最多只有一个进程在管程中执行。
- Wait(C)：将调用此函数的进程挂起并在与条件变量C相对应的队列中
- SignalC(C)：恢复某个由于在条件变量C上被挂起的进程

### 调度

#### 高级调度

- 称为作业调度或长程调度

#### 进程调度

- 非抢占方式
  - 实现简单，系统开销小
  - 难以满足紧急的任务立即执行
- 抢占方式
  - 开销大
  - 为全体进程提供更好的服务
- 抢占原则
  - 优先权原则：优先权高的进程有权抢占优先级低的进程的CPU
  - 短作业优先原则：就绪的短作业有权抢占长作业的CPU
  - 时间片原则

#### 进程调度方法分类

- 批处理：通常采用非抢占式算法
- 交互式：通常采用抢占式算法
- 实时：通常采用抢占式算法

#### 进程调度的考量标准

- 响应时间：进入就绪队列与用CPU的时间的间隔
- 周转时间：进入队列到结束执行的时间间隔
- CPU吞吐量：单位时间内运行结束的进程个数
- 带权周转时间：$\frac{周转时间}{运行时间}$

#### 先来先服务（FCFS）

- 根据进程到达就绪队列的时间来分配中央处理机，一旦一个进程获得了中央处理机
- 就直运行到结束,先来先服务是非抢占调度
- 有利于长进程，不利于短进程
- 实现简单，效率低

#### 短进程优先调度算法（SJF）

- 算法易于实现,能有效降低作业的平均等待时间
- 对长作业不利，有可能导致长作业（进程）长期不被调度
- 未能依据作业的紧迫程度来划分执行的优先级
- 难以准确估计作业（进程）的执行时间，未必能真正做到短作业优先,从而影响调度性能。

![image-20201019170021081](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201019170021081.png)

<center>因为A到的时候队列只有A，所以A是最短的，A先执行</center>

#### 时间片轮转法

- ![image-20201019170210159](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201019170210159.png)

- ![image-20201019170448613](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201019170448613.png)
  - 在箭头处，C执行完时，时间片时间未到，D是新开一个时间片
- 时间片长短
  - 时间片越短，响应时间越短
  - 时间片越长，切换上下文开销越大

#### 优先级调度

##### 静态优先级

- 在创建进程时确定，在运行中不会改变
- 实现简单，但是可能导致优先级低作业长时间没被调度

##### 动态优先级

- 在创建进程时所确定的优先权,可以随着进程的推进而改变

##### 多级反馈队列调度算法( Feed back,FB)

![image-20201019172237154](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201019172237154.png)

- 将就绪队列分为N级，每个就绪队列分配给不同的时间片，队列优先权越高，时间片越小
- 新进程进入内存后，放入第一队列未尾，按FCFS原则等待调度
- 如果在一个时间片结束时没完成,将该进程转入第二队列末尾重新等待调度执行….如此下去
- 当一个长作业从第一级队列降到最后一级队列时,便在该队列中采取时间片轮转方式运行。