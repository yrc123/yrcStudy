# 计算机系统结构概论

## 计算机系统的多级层次结构

| 层级   | 名称                   | 作用                                                         |
| ------ | ---------------------- | ------------------------------------------------------------ |
| 第一级 | 微程序机器级           | 是实现机器指定功能的中央控制部分，可采用硬联逻辑实现         |
| 第二级 | 传统机器级（机器语言） | 传统机器级的机器语言是该机的指令集，用机器指令集编写的程序可以由微程序进行解释。<br/>不同指令集可以有多个解释程序，可以通过仿真在一台机器上实现多种指令集。 |
| 第三级 | 操作系统虚拟机         | 直接管理传统机器中的软硬件资源。<br/>是传统机器的引伸，如文件系统、多线程管理等。<br />由机器语言程序或微指令程序解释。 |
| 第四级 | 汇编语言虚拟机         | 汇编语言虚拟机的机器语言是**汇编语言**。<br/>翻译或解释成第3级和第2级语言，然后再由相应的机器执行。<br />完成汇编语言翻译的程序就叫做汇编程序。 |
| 第五级 | 高级语言虚拟机         | 高级语言虚拟机的机器语言就是各种**高级语言**。<br/>一般翻译到第４级或第2级上，个别的高级语言也用解释的方法实现。 |
| 第六级 | 应用语言虚拟机         | 应用语言虚拟机是为使计算机满足某种用途而专门设计的。<br/>应用语言编写的程序一般是由应用程序包翻译到第5级上。 |

## 计算机系统结构、组成、实现的定义、内涵和相互关系

- Amdahl给出的定义
  - 计算机系统结构就是程序员所看到的计算机的基本属性，即概念性结构与功能特性。
- 计算机系统结构的经典定义
  - 指计算机系统多级层次结构中机器语言机器级的结构，它是软件和硬件/固件的主要交界面，是由机器语言程序、汇编语言源程序和高级语言源程序翻译生成的机器语言目标程序能在机器上正确运行所应具有的**界面结构**和**功能**。
- 计算机组成定义
  - 计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等。
- 计算机实现定义
  - 指的是计算机组成的物理实现，包括处理机、内存等部件的物理结构，器件的集成度和速度，器件、模块、插件、底板的划分与连接，专用器件的设计，微组装技术，信号传输，电源、冷却及整机装配技术等。
- 计算机系统结构、组成和实现的相互关系
  - 相同结构的计算机，可以因速度不同而采用不同的组成
  - 一种组成可以有多种不同的实现方法
  - 结构不同会使可能采用的组成技术不同
  - 组成也会影响结构
  - 组成设计向上决定于结构，向下受限于实现技术，但组成可以与实现折中权衡

## 计算机的基本性能指标及Amdahl定律

- 计算机性能 
  - 体现于时间和空间两个方面。在系统上程序实际运行的时间是衡量机器时间性能最可靠的标准

### 计算机的基本性能指标 

- 一些名词
  - 时钟频率
    - 取决于硬件技术和组织
  - 平均时钟周期数CPI
    - 平均每条指令的平均时钟周期个数
    - 取决于系统结构及指令集的设计与实现
    - $CPI=(\sum^n_{i=1}CPI_i\times \frac{I_i}{IC})$
  - 程序使用的指令条数IC：
    - 总的指令数
    - 取决于系统结构的指令集和编译技术
  - CPU的时钟周期数：
    - $T_{total}={\sum^n_{i=l}(CPI_i\times I_i)\times T_c}$
- 指令i的使用频度：
    - $\frac{I_i}{IC}$
  
- 单CPU性能
  - CPU时间 = CPU时钟周期数 × 时钟周期 （$T_{cpu}=T_{total}\times T_c$）
  - CPU时间 = CPU时钟周期数 / 时钟频率 （$T_{cpu}=T_{total}\times \frac{1}{f_c}$）
  - CPI = CPU时钟周期数 / IC （$CPI=T_{total} \times \frac{1}{IC}$）
  - CPU时间 = （IC × CPI） / 时钟频率 （$T_{cpu}=IC\times CPI\times \frac{1}{f_c}$）

### Amdahl定律

- 加速比
  - $S_n=\frac{T_0}{T_n}$
- Amdahl定律
  - Fe：改进前可被改进部分的执行时间相对$T_0$的百分比
  - Se:  可被改进部分改进前执行时间对改进后执行时间的比值
  - $$\begin{aligned} T_n &= T_0\times(1-Fe)+\frac{T_0\times Fe}{Se} \\  &=T_0\times(1-Fe+\frac{Fe}{Se})  \end{aligned}$$
  - $S_n=\frac{T_0}{T_n}=\frac{1}{1-Fe+Fe/Se}\ (0\le Fe\le1,Se\ge 1 )$
  - $Sn=\frac{1}{1-Fe}(\frac{1}{1-Fe}\>Sn\ge1,Se\to \infty)$

## MIPS和MFLOPS

- MIPS
  - 表示每秒百万**指令条数**
  - $MIPS=\frac{指令条数}{执行时间\times 10^6}=\frac{时钟频率}{CPI\times 10^6}$
  - 适用于衡量标量处理机性能，不适用衡量向量处理机
- MFLOPS 
  - 表示每秒百万浮点**操作**次数
  - 只能反映机器执行浮点操作的性能，并不能反映机器的整体性能
  - 是通过浮点操作来衡量，而不是通过指令来衡量。因此可用来比较不同指令集的机器之间的浮点操作性能

## 程序访问的局部性定律

- 时间局部性
  - 最近的将来要用到的信息很可能是现在正在使用的信息，这是因为程序存在着循环
- 空间局部性
  - 最近的将来要用到的信息很可能与现在正在使用的信息在程序位置上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据也通常是以向量、阵列、树、表等形式聚族地存放在一起

## 并行性的含义

- 并行性
  - 是指同一时刻或同一时间间隔内发生两种或两种以上性质相同或不相同的事件。 

## 并行性开发的途径

- 时间重叠
  - 在并行性中引入时间因素，让多个处理过程在时间上错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件使用周转来提高处理速度。
  - ![image-20200727215049984](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727215049984.png)
- 资源重复
  - 在并行性概念中引入空间因素，通过重复设置硬件资源来提高系统可靠性或性能
  - ![](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727215038045.png)
- 资源共享
  - 利用软件的方法让多个用户按一定时间顺序轮流地使用一套资源，以提高系统资源利用率，也可以相应提高整个系统的性能
  - ![image-20200727215209438](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727215209438.png)

## 并行性等级的划分

- 按计算机系统中执行程序的并行性划分（从上到下硬件比例减小）

  - 指令内部并行
    - 一条指令内部各个微操作之间的并行
    - 关键是硬件和组成的设计
  - 指令之间并行
    - 多条指令的并行执行
    - 关键是如何处理好指令之间存在的关联
  - 任务或进程之间并行
    - 多个任务或程序段的并行执行
    - 关键是如何进行任务分解和同步
  - 作业或程序之间并行
    - 多个作业或多道程序的并行
    - 关键是并行算法，如何进行资源的有效分配
- 按计算机信息加工的并行性划分
	- 存储器操作并行
    - 可用单体多字、多体单字或多体多字方式在一个存储周期内访问多个字
    - 采用按内容访问方式在一个存储周期内用位片串字并或全并行方式实现对存储器中大量字的高速并行比较、检索、更新、变换等
    - 典型例子是并行存储器系统和以相联存储器为核心构成的相联处理机
  - 处理器操作步骤并行
    - 处理器操作步骤可以是一条指令的取指、分析、执行等操作步骤，也可以是浮点加法的求阶差、对阶、尾加、舍入、规格化等具体操作的执行步骤，可以重叠流水执行
    - 典型例子是流水线处理机
  - 处理器操作并行
    - 通过重复设置大量处理单元，让它们在同一控制器控制下按同一指令要求对向量、数组中各元素同时操作
    - 典型例子是阵列处理机 
  - 指令、任务、作业并行
    - 是多个处理机同时对多条指令及有关的多个数据组进行处理，构成多指令流多数据流计算机
    - 典型例子是多处理机
    - 指令级以上的并行是多个处理机同时对多条指令和相关的多数据组进行处理，操作级并行是对同一条指令及其相关的数据组进行处理。前者属于MIMD，后者属于SIMD计算机。
- 按计算机系统处理数据的并行性划分
  - 位串字串
    - 同时只对一个字的一位进行处理
    - 串行单处理机
  - 位并字串
    - 同时对一个字的全部位进行处理
    - 并行单处理机
  - 位片串字并
    - 同时对许多字的同一位（称位片）进行处理
    - 某些相联处理机及阵列处理机
  - 全并行
    - 同时对许多字的全部或部分位组进行处理
    - 某些相联处理机，大多数阵列处理机及多处理机

## Flynn分类法

- 指令流：指机器执行的指令序列。
- 数据流：指由指令流调用的数据序列，包括输入数据和中间结果，但不包括输出数据。
- 多倍性：指在系统性能瓶颈部件上同时处于同一执行阶段的指令或数据的最大可能个数。
- Flynn分类法按**指令流和数据流的多倍性**对计算机系统结构进行分类

### 单指令流单数据流体系结构（SISD）

![image-20200727220153369](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727220153369.png)

- 可能设置多个并行存储体和多个执行部件
- 所有功能部件均由一个控制部件管理
- 指令部件每次只对一条指令译码，只对一个操作部件分配数据
- 传统单处理器计算机

### 单指令流多数据流体系结构（SIMD）

![image-20200727220206277](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727220206277.png)

- 典型例子是阵列处理机和相联处理机
- 在同一CU管理下，有多个PU，所有PU均收到从CU送来的同一条指令，但操作对象却来自不同数据流的数据
- 共享存储器可以有多个存储器模块，可以同时为多个PU提供不同的数据

### 多指令流单数据流体系结构（MISD）

![image-20200727220241454](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727220241454.png)

- 有多个PU，各自有CU，每个PU接收不同的指令，但运算对象是同一个数据流及其派生数据流

- 一个处理单元的输出作为另一个处理单元的输入
- 这类结构没有实用价值

- 有人把处理机间的宏流水归属于该系统

### 多指令流多数据流体系结构（MIMD）

![image-20200727220247676](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200727220247676.png)

-  如果n个处理机之间存在相互作用，因为所有数据流均来源于全体处理机共享的同一个数据空间，属于紧密耦合系统
- 如果n个数据流来源于共享存储器的不相邻子空间，可视为多SISD操作，是n个独立的SISD单处理机系统的集合，是松散耦合系统。如多计算机系统
- 能实现作业、任务、指令、数组各级全面并行

# RISC结构

## 操作码优化设计方法：定长编码、哈夫曼编码、扩展编码法

### 操作码优化编码的评价方法

- 平均码长
  - $l=\sum^n_{i=1}p_il_i$
  - $p_i$是码点i的使用频度，$I_i$是码点i的编码长度
- 位冗余量
  - $R=\frac{l-H}{l}$
- 信息熵
  - $H=\sum^n_{i=1}p_ilog_2(p_i)$
  - 理论上的最短平均编码长度

### 定长（等长）编码

- 所有指令的操作码长度都是相等的
- 如果需要编码的操作码有n个，则定长操作码的位数最少需要$log_2n$位
- 定长编码的优缺点
  - 规整性好
  - 解码简单
  - 占用空间大

### 哈夫曼编码法

- 使用哈夫曼算法构造哈夫曼树

### 扩展编码

- 限定使用少数几种码长，频率高的码点用短码表示，频率低的码点用长码表示
- 任何短码都不能是任何长码的前缀，否则会造成解码的不惟一性
- 需要留下若干个短码作为长码的扩展标志，以便长码在扩展编码时使用
-  扩展编码的表示法
  - 码长表示法：用短横线前后的数字分别表示短码码长和长码码长
    - 2-4-6 表示编码有3种码长，分别是2位、4位和6位
  - 码点数表示法：用斜线前后的数字分别表示短码码点个数和长码码点个数
    - 3/6/4 表示3种码长，最短码长的码点个数是3，最长码长的码点个数是4，码点总数是13
    - ![image-20200728230453181](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200728230453181.png)

## CISC的主要问题

-  CISC的主要问题
  - 20%与80%规律：80%左右的指令很少使用，它们的使用量约占整个程序的20%。
  - 指令复杂，实现工艺复杂

## RISC结构的特点

- 大多数指令在单周期内完成
- 采用LOAD/STORE结构：除Load/Store两种指令，其余指令都不能访存，以便使除这两种指令外的所有指令都能在单周期内完成

- 扩大通用寄存器数，一般不少于32个

- 采用硬布线控制逻辑：可使大多数指令在单周期内完成

- 减少指令和寻址方式的种类：可以简化控制部件的结构，加快指令的执行速度
- 采用固定的指令格式：不仅可以使指令的译码电路简化，而且便于采用流水技术提高程序的执行速度
- 注重编译程序的优化设计：由于RISC精简了支持编译的某些专门指令，因此，RISC上的编译程序要比CISC的难写。

## RISC的关键技术

- 重叠寄存器窗口技术
  - 可以直接从前一个寄存器中获取上一个过程的数据，而不用从硬盘获取
  - ![image-20200729172208602](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729172208602.png)
- 指令的执行采用流水和延迟转移技术
  - 流水
    - 在时间上重叠
    - 大多数RISC指令的操作都在寄存器中进行，因此执行时又可将从源寄存器读数、运算及运算结果打入目的寄存器三者之间用流水实现
  - 延迟转移
    - 将转移指令与其前面一条或多条指令对换一下位置，让成功转移总是在紧跟的指令被执行之后发生，从而使预取的指令不必作废
    - ![image-20200729180843015](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729180843015.png)
- RISC优化编译技术

# 流水和指令级高度并行的超级机

## 流水线的分类

### 按流水线各功能段间是否有反馈回路

- 线性流水线
  - ![image-20200729201945116](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729201945116.png)
- 非线性流水线
  - ![image-20200729202024846](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729202024846.png)

### 按流水线流出任务是否按序

- 顺序流动流水线
- 乱序流动流水线
  - 又分为无序流水线和错序流水线

### 按流水线具有的功能多少

- 单功能流水线
  - 各段之间的连接固定不变，仅能实现单一功能
- 多功能流水线
  - 各段可以实现不同的连接，能通过不同的连接实现不同的处理功能

### 按多功能流水线能否在同一段时间内实现多种连接

- 静态流水线
  - 在同一段时间内，多功能流水线只能实现一种连接，只有等该连接流入的所有处理对象排空后才能实现另一种连接
  - 
- 动态流水线
  - 在同一段时间内，多功能流水线的各段可以实现多种连接，从而执行多种功能。

### 按处理的级别

- 部件级流水线
  - 指由部件内各子部件组成的流水线
  - 例如由指令分析部件的译码、地址形成、取操作数等子部件组成指令分析部件流水线
- 处理机级流水线
  - 处理机内的各部件之间的流水线
  - 例如，由取指部件、指令分析部件和指令执行 部件组成的指令流水线
- 系统级流水线

### 按机器的数据表示

- 标量流水处理机
- 向量流水处理机

## 指令的重叠与一次重叠

- 指令重叠
  - ![image-20200729194312274](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729194312274.png)
  - 解决访主存冲突的方案
    - 让操作数和指令分别存放在两个**独立编址**且**可同时访问**的存储器中
    - 仍维持指令和操作数混存，但采用多体交叉主存结构

    - 增设采用先进先出方式工作的指令缓冲寄存器
  - 解决“分析”和“执行”操作的并行
    - 硬件上还应有独立的指令分析部件和指令执行部件，这是以增加某些硬件为代价的
  - 解决”分析“和”执行”操作控制上的同步
    - 需在硬件中解决控制上的同步，保证任何时候都只是“执行k”和”分析k+1”重叠 
- 一次重叠
  - 指令分析部件和指令执行部件任何时候都只有相邻两条指令在重叠解释的方式称为“一次重叠”

## 线性流水线的性能计算

- 吞吐量

  - 流水线单位时间流出结果的数量


- 各段执行时间相等的吞吐率
  - $TP=\frac{n}{(k+n-1)\Delta t}$
  - ![image-20200729223215583](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729223215583.png)
-  各段执行时间不相等的吞吐率
  - $TP=\frac{n}{\sum^k_{i=1}\Delta t+(n-1)max(\Delta t_1,\Delta t_2,...,\Delta t_k)}$
  - ![image-20200729224413992](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729224413992.png)
- 分离瓶颈段
  - ![image-20200729225047651](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729225047651.png)
- 重复设置瓶颈段
  - ![image-20200729225155276](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729225155276.png)
- 加速比
  - $S=\frac{顺序方式处理一批对象所用时间}{流水方式处理一批对象所用时间}$
- 效率
  - $E=\frac{流水线各段有效工作的时间之和}{流水线各段被占用时间之和}$
  - $E=\frac{处理对象实际占用的时空面积之和}{时空图总面积}$

## 非线性流水线的调度与性能计算

1. 建立预约表

   | 段/时间 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | $S_1$   | Y    |      |      |      |      |      |      |      | Y    |
   | $S_2$   |      | Y    | Y    |      |      |      |      |      |      |
   | $S_3$   |      |      |      | Y    |      |      | Y    | Y    |      |
   | $S_4$   |      |      |      | Y    | Y    |      |      |      |      |
   | $S_5$   |      |      |      |      |      | Y    | Y    |      |      |

2. 由预约表得出禁止表 

   | 段    | 禁止表                             |
   | ----- | ---------------------------------- |
   | $S_1$ | $\{8\Delta t\}$                    |
   | $S_2$ | $\{\Delta t\}$                     |
   | $S_3$ | $\{\Delta t,3\Delta t,4\Delta t\}$ |
   | $S_4$ | $\{\Delta t\}$                     |
   | $S_5$ | $\{\Delta t\}$                     |

3. 由禁止表得出初始冲突向量

   - $C_0=(c_nc_{n-1}...c_k...c_2c_2)$
   - $C_0=(10001101)$
   - ![image-20200729230937160](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729230937160.png)

4. 由初始冲突向量得出状态有向图

   - ![image-20200729232219267](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729232219267.png)
   - ![image-20200729232318803](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200729232318803.png)
   - shr(n)为右移n位相当于时间经过n，而与运算相当于在当前时间的状态下再流入一条指令C0
   - C3可以shr(5-7)是因为C3(10001111)中c5,c6,c7都是0
   - ![image-20200730002041790](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730002041790.png)

5. 由状态有向图得出最优调度策略

   - 从初始状态出发，构造多种调度间隔呈周期性重复的方案，选择平均时间间隔最小的调度策略
   - ![image-20200730002232725](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730002232725.png)

6. 设连续流入n个对象，计算最优调度策略的流水线吞吐率，加速比和效率

   - ![image-20200730004210020](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730004210020.png)

## 相关的类型及其处理

### 转移指令的处理

![image-20200730210036234](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730210036234.png)

- 延迟转移
  -  由编译程序生成目标程序时，将转移指令与条件转移无关的第k-1条指令交换位置
  - ![image-20200730210417601](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730210417601.png)

### 主存空间数相关的处理

![image-20200730211700610](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730211700610.png)

- 是指相邻两条指令之间出现对主存同一单元要求先写而后读的关联
- 解决方案
  - ![image-20200730211829791](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730211829791.png)
  - 推后读常见的方法是由存控给读数、写数申请安排不同的访存优先级来解决。

### 通用寄存器组相关的处理

![image-20200730212410158](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730212410158.png)

- 假设机器的基本指令格式如上

![image-20200730212002700](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730212002700.png)

- 存放于通用寄存器中的**基址值或变址值**一般是在“分析”周期的**前半段**取用；**操作数**是在“分析”周期的**后半段**取出，到“执行”周期的**前半段**才用；**运算结果**是在“执行”周期的**末尾**形成并存入通用寄存器中。
- 解决方案
  - ![image-20200730212452771](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730212452771.png)
  - 推后“分析k+1”的读到“执行k”结束时开始以降低速度为代价
  - 推后到“执行k”把结果送入L3，然后再由“分析k+1”在取(L1)或(L2)时能取到即可，速度损失减小，但控制较复杂

  - 相关专用通路，执行k可以在将运算结果送入通用寄存器完成其应有功能的同时，直接将运算结果回送到B或C寄存器

### 数据相关的类型

- 数据相关有三种类型
  - RAW|先写后读
    - ![image-20200730212746056](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730212746056.png)
    - 是指令j试图在指令i（j>i）写入寄存器之前读取寄存器中的数据，这样指令j读出的就是其原来的内容，简称为读超前于写。**真相关**
  - WAR|先读后写
    - ![image-20200730212852314](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730212852314.png)
    - 是指令j试图在指令i读出寄存器中的数据之前写入寄存器，这样指令i读出的就是寄存器中的新内容，简称为写超前于读。反相关 
    - 由于在静态流水线中，读操作发生得早，写操作发生得晚，因此不会发生WAR相关。
  - WAW|先写后写
    - ![image-20200730213616618](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730213616618.png)
    - 是指令j试图在指令i写入寄存器之前写入寄存器，这样两条指令的写入过程颠倒，简称为j写超前于i写。输出相关
    - WAW只在特定类型的流水线中才会发生，这些流水线允许在多个流水段进行写操作，或者允许后续指令在前面指令停顿的情况下继续执行。
  - 循环相关
    - 将循环体展开后下一次循环与上一次循环之间存在的RAW、WAR、WAW相关

### 寄存器基址值或变址值相关的处理

![image-20200730214703442](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730214703442.png)

- 一次重叠时，不止会出现一次相关，还会出现二次相关
- 解决方案
  - 退后分析
  - ![image-20200730214942992](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730214942992.png)
  - ![image-20200730214954683](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730214954683.png)

### 顺序流动的先写后读相关及处理，异步流动的局部相关，先写后读相关、先读后写相关、写写相关的测试方法，相关专用通路

- 内部数据定向的原则
  
- 是要消除一些不必要的访存储器或访寄存器的中间环节，从而减少资源和数据的相关性，以提高流水线的吞吐率。
  
- 先写后读定向 

  - ![image-20200730215138422](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730215138422.png)

- 先读后读定向 

  - ![image-20200730215307509](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730215307509.png)

- 先写后写定向

  - ![image-20200730215203946](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730215203946.png)

-  相关专用通路

  - ![image-20200730223200657](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730223200657.png)

- 顺序流动的”先写后读”相关及处理

  - ![image-20200730230549191](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730230549191.png)

  - 设指令h的目的操作数与指令j的源操作数地址相同

  - 如果能控制前半周期写，后半周期读

  - | 功能段    | $S_1$ | $S_2$ | $S_3$ | $S_4$ | $S_5$ | $S_6$ | $S_7$ | $S_8$ |
    | --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | $t_i$     | k     | j     | i     | h     |       |       |       |       |
    | $t_{i+1}$ | k     | j     |       | i     | h     |       |       |       |
    | $t_{i+2}$ | k     | j     |       |       | i     | h     |       |       |
    | $t_{i+3}$ | k     | j     |       |       |       | i     | h     |       |
    | $t_{i+4}$ | l     | k     | j     |       |       |       | i     | h     |
    
  - 如果不能控制前半段读后半段写
  
  - | 功能段    | $S_1$ | $S_2$ | $S_3$ | $S_4$ | $S_5$ | $S_6$ | $S_7$ | $S_8$ |
      | --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
      | $t_i$     | k     | j     | i     | h     |       |       |       |       |
      | $t_{i+1}$ | k     | j     |       | i     | h     |       |       |       |
      | $t_{i+2}$ | k     | j     |       |       | i     | h     |       |       |
      | $t_{i+3}$ | k     | j     |       |       |       | i     | h     |       |
      | $t_{i+4}$ | k     | j     |       |       |       |       | i     | h     |
    | $t_{i+5}$ | l     | k     | j     |       |       |       |       | i     |
  
- 异步流动方式
  - | 功能段    | $S_1$ | $S_2$ | $S_3$ | $S_4$ | $S_5$ | $S_6$ | $S_7$ | $S_8$ |
    | --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | $t_i$     | l     | k(j)  | i     | h     |       |       |       |       |
    | $t_{i+1}$ | m     | l(j)  | k     | i     | h     |       |       |       |
    | $t_{i+2}$ | n     | m(j)  | l     | k     | i     | h     |       |       |
    | $t_{i+3}$ | n     | j     | m     | l     | k     | i     | h     |       |
    | $t_{i+4}$ | o     | n     | j     | m     | l     | k     | i     | h     |
    
  - 如果不能控制前半段读后半段写
  
  - | 功能段    | $S_1$ | $S_2$ | $S_3$ | $S_4$ | $S_5$ | $S_6$ | $S_7$ | $S_8$ |
      | --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
      | $t_i$     | l     | k(j)  | i     | h     |       |       |       |       |
      | $t_{i+1}$ | m     | l(j)  | k     | i     | h     |       |       |       |
      | $t_{i+2}$ | n     | m(j)  | l     | k     | i     | h     |       |       |
      | $t_{i+3}$ | o     | n(j)  | m     | l     | k     | i     | h     |       |
      | $t_{i+4}$ | o     | j     | n     | m     | l     | k     | i     | h     |
    | $t_{i+5}$ | p     | k     | j     | n     | m     | l     | k     | i     |

- “先写后读”相关的测试方法

  - 在流水线的**读功能段**设置一个相联比较器，在指令读数之前，将待读源操作数的地址与读段和写段之间指令的目标地址进行比较

- 异步流动的局部相关

  - 采用异步流动可以提高流水线的吞吐率和效率

  - 但会出现两种新的相关：“写—写”相关和“先读后写”相关

- 先读后写”相关的测试方法

  - 在流水线的**写功能段**设置一个相联比较器，在指令写数前，将目标地址与已进入流水线但尚未到达或刚到达读段的序号较其小的指令的源操作数地址进行比较

- “写—写”相关的测试方法

  - 在流水线的写功能段设置一个相联比较器，在指令写数前，将目标地址与已进入流水线但尚未到达写段的序号较其小的指令的目标地址进行比较

### 全局相关的处理

- 全局相关
  - 影响整个程序执行方向的相关，主要是转移指令和中断引起的相关
  - 转移条件码是由条件转移指令本身或它的前一条指令形成的，则只有该指令流出流水线后才能建立转移条件，并由此决定下一条指令的地址
  - 从指令进入流水线、译码出它是条件转移指令直至它流出的整个期间，流水线就不能继续流入新指令
  - 若转移成功且转向的目标指令又不在指令缓冲器内，还得要重新从访存取指令开始流动
- 全局相关的处理
  - 猜测法
    - 在遇到条件转移指令时，为了使流水线不“断流”，通常采用猜测法。
    - 如果两个分支概率相近，宜选转移不成功分支
    - 如果两个分支概率不均等，宜猜高概率分支
  - 静态预测
    - 可以静态地根据转移指令类型或程序执行期间转移的历史状况来预测
    - 在处理机的软件和硬件设计完成之后，选择的转移猜测方向就已经确定了
  - 动态预测
    - 是根据近期转移是否成功的历史记录来预测下一次转移的方向
    - 由编译程序根据执行过程中转移的历史记录来动态预测未来的转移选择
- 采用猜测法时应能保证猜错时可恢复分支点原先的现场
  - ![image-20200730233457995](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730233457995.png)
  - 第一种方法
    - ![image-20200730233511764](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200730233511764.png)
    - 一种是对条件转移指令后的几条指令只进行指令译码和读操作数，在转移条件没有形成之前**不执行运算**，因此也不写回运算结果
    - 无论是否猜对都产生浪费
    - 逻辑简单
  - 第二种方法
    - 对条件转移指令后的几条指令一直进行到运算完成，但不把运算结果写回通用寄存器或主存单元，而是送往专门的缓冲寄存器
    - 减少浪费
    - 逻辑复杂

### 加快和提前形成条件码

- 尽可能在运算开始或中间产生条件码

### 采用延迟转移技术

- 依靠编译器把转移指令之前的一条或几条没有数据相关和控制相关的指令调整到转移指令之后，转移指令被延迟执行
- 被移动的指令不破坏条件转移指令使用条件码
- 如果找不到符合条件的指令，则在条件转移指令后插入空指令

### 中断处理

- 不精确断点法
  - 中断后禁止后续指令流入流水线，但已进入流水线的指令都执行完成，断点指令是最后进入流水线的指令
  - 需要的硬件较少，控制逻辑较简单，保存和恢复现场的工作量较小
  - 中断响应时间加长
- 精确断点法
  - 断点指令即发出中断申请的指令
  - 断点指令后已进入流水线的指令全部作废，立即转入中断服务程序
  - 能精确保存和恢复断点现场
  - 控制逻辑较复杂

## 多发射处理机及其性能

### 超标量处理机及其性能计算

![image-20200731224702211](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731224702211.png)

- 超标量处理机
  - 在一个时钟周期内能够同时发射多条指令的处理机
  - 是在单发射处理机的基础上，采用资源重复的途径来发展指令流水线的并行性
- 超标量处理机的性能
  - $T(1,1)=(k+N-1)\Delta t$
  - $T(m,1)=(k+\frac{N-m}{m})\Delta t$
  - $S(m,1)=\frac{T(1,1)}{TJ(m,1)}=\frac{m(k+N-1)}{N+m(k-1)}$

### 超流水处理机及其性能计算

![image-20200731224739662](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731224739662.png)

-  超流水处理机
  - 是在单发射处理机的基础上，采用时间重叠的途径来发展指令流水线的并行性
  - 通过把单发射的指令流水线各功能段进一步细分来提高处理机的指令级并行度
  - 能在一个基本时钟周期内分时发射多条指令
  - 把原k段的指令流水线每段细分为n段的超流水线的流水线周期为$\frac{\Delta t}{n}$
- 超流水线处理机的性能
  - $T(m,1)=(k+\frac{N-1}{n})\Delta t$
  - $S(1,n)=\frac{T(1,1)}{T(1,n)}=\frac{n(k+N-1)}{nk+N-1}$

### 超标量超流水处理机

![image-20200731230135645](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731230135645.png)

- 超标量超流水线处理机
  - 把超标量技术和超流水线技术结合应用的处理机
  - 超标量超流水处理机的指令流水线的每一个时钟周期分为n个流水线周期，每一个流水线周期同时发射m条指令，因此，每个时钟周期能够发射mn条指令
- 超标量超流水处理机的性能
  - $T(m,n)=(k+\frac{N-m}{mn})\Delta t$
  - $S(1,n)=\frac{T(1,1)}{T(m,n)}=\frac{nm(k+N-1)}{nmk+N-m}$

### 三种多发射处理机的性能比较

![image-20200731230306009](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731230306009.png)

![image-20200731230319990](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731230319990.png)

- 超标量处理机>超标量超流水线处理机>超流水线处理机
- 超流水线处理机的启动延迟通常要比超标量处理机大

### 超长指令字处理机

![image-20200731230420967](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731230420967.png)

- 超长指令字（VLIW）处理方式
  - 把一个足够长的指令分割成多个字段，每个字段都可以独立地控制各自的运算器、寄存器、互连 网络（矩阵开关）和存储器等
- VLIW处理机的超长指令构成
  - 可并行执行的n个运算器控制指令字段
  - 若干个访问存储器控制指令字段
  - 其它控制字段
- 超长指令字方式的基本过程
  - 由编译程序对原程序中的指令判断并行运算的可能性，编译时将多个功能并行执行的不相关或无关的操作先行压缩组合在一起，组成一条有多个操作段的超长指令
- VLIW方式与超标量处理方式的比较
  - 均可在一个时钟周期同时发射多条指令  
  - VLIW处理机的并行调度在编译期间完成
  - 超标量处理机的并行调度在运行期间完成
  - VLIW处理机可扩充性差：要重新设计指令
  - 超标量处理机可扩充性好：增加PU的个数就可提高同时发射的指令条数
  - VLIW指令因其格式固定，故而VLIW指令的译 码比超标量指令译码容易
  - 超标量处理机的兼容性优于VLIW处理机

## 向量处理机的链接技术

-  向量处理技术与向量处理机
  - 向量处理—使用向量指令和向量操作硬件（向量寄存器，流水线功能部件等）并行处理多个或多对向量元素
  - 根据向量处理机使用向量指令并发还是同时对多个或多对向量元素进行处理，可分为向量流水处理机和并行阵列处理机
- 编队
  - 编队——向量指令序列中不存在资源争用冲突和数据相关，**可同时并行执行**的n条向量指令构成的序列
  - 编队执行时间——编队内需时最长的那条向量指令的执行时间
- 向量指令类型
  - $V_k\gets V_i\ op\ V_j$
  - $V_k\gets S_i\ op\ V_j$
  - $V_k\gets Men$
  - $V_i$指向量寄存器
  - $S_i$指标量寄存器
  - Mem是主存
- 链接技术
  - ![image-20200731234419762](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200731234419762.png)
  - 如果相邻的多条向量指令之间**无功能部件的使用**冲突和**向量寄存器**（源和目的）的使用冲突，只有向量寄存器的**先写后读相关**，可通过**向量流水线链接**实现向量指令间的流水操作
  - **向量流水线链接**——将前一条向量指令流水线**流的结果向量元素直接链入**后续向量指令所用的流水线，使多个向量流水线之间的功能部件链接构成**一条大的流水线**
  - 在进行链接时，只有在前一条向量指令的**第一个结果元素流入结果向量寄存器的时钟周期**才能进行链接，错过该时刻则不能进行链接。如果后一条指令要链接，则必须提前一拍从指令字寄存器中流出，一旦错过时间则无法链接
  - 只有所有可链接执行的向量指令的向量长度相等时，它们之间才能链接执行
  - 当一条向量指令的两个源操作数分别是两条先行向量指令的结果寄存器时，要求先行两条向量指令能在同一个时钟周期得到第一个分量
- 功能部件冲突
  - 同一个功能部件被要求并行工作的多条向量指令所使用
  - 例子
    - $V_4\gets V_2\times V_3$
    - $V_5\gets V_1\times V_6$
    - 两个指令要浮点乘流水功能部件，只能顺序执行

# 阵列处理机

## 互连函数

- 互连网络是用来连接计算机系统内部多个部件的
- 动态互连网络可通过设置有源开关，从而根据需要借助控制信号对连接通路加以重新组合，实现所要求的通信模式。

### 多级互连网络

![image-20200801230247408](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801230247408.png)

- 开关模块
  - ![image-20200801230417138](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801230417138.png)
  - 若一级有$a^n$输入、$b^n$输出，则一级有$\frac{a^n}{a}=a^{n-1}$个开关，有$b(a^{n-1})$个输出，二级的输入和一级的输出相同
  - 关内部的信号传输路径
    - ![image-20200801231403942](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801231403942.png)
    - 以上为合法
    - ![image-20200801231549506](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801231549506.png)![image-20200801231555821](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801231555821.png)
    - 以上为非法，因为信号从同一输出通路输出，会产生信号的干扰

### 控制方式

- 级控方式
  - 对同一级的所有开关用一个控制信号控制
- 组控方式
  - 对第i级的开关分为i+1组，每组用一个控制信号控制（0≤i ≤n-1）
- 单元控制方式
  - 每一个开关有自己单独的控制信号

### 多级互连网络的分类

- 阻塞网
  - 两个或两个以上的输入可能会争用同一个输出通路，即产生路径争用冲突。这样，这样的两个或两个以上的连接就不能同时实现
  - 所用开关数量少，延时不长，路径控制较简单。
- 可重排非阻塞网络
  - 可能出现路径争用冲突，但是通过改变路径，就可以消除冲突
- 多级非阻塞网络
  - 不会产生路径争用冲突

### 均匀洗牌置换

![image-20200801235131692](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801235131692.png)

- 把输入端二进制地址**循环左移一位**就是连接的输出端的二进制地址

![image-20200801235337274](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801235337274.png)

- 如4(100)洗牌后为1(001)

### 逆洗牌置换

![image-20200802010039552](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802010039552.png)

- 把输入端二进制地址**循环右移一位**就是连接的输出端的二进制地址

### 恒等置换

![image-20200801235517971](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801235517971.png)

- 就是输出端和输入端相同

### 蝶式置换

![image-20200802004819684](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802004819684.png)

- 可见输出端序列是输入端序列的最高位和最低位互换位置，其余位不变
- 000-->000   001-->100  010-->010   011-->110  100-->001  101-->101  110-->011  111-->111

### 分组置换

- 若N=8,n=3，分为2组，每组4元素
- 则第一组有000，001，010，011，第二组有100，101，110，111
- 第一组置换为$000\to 011,001\to 010,010\to 001,011\to 000$，第二组同理

### 移数置换

![image-20200802141621300](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802141621300.png)

![image-20200802141638219](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802141638219.png)

- 把输入端的端号序列循环左移或循环右移若干位就是输出端的端号序列。

### 位序颠倒置换

![image-20200802170543634](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802170543634.png)

## 动态互连网络

### Omega网络

![image-20200801233147349](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200801233147349.png)

- Omega网络输入和输出个数都是N，共n级开关，每个开关是$2\times2$的，那么每级有$N/2$个开关，有$n=log_2N$级，共$(N/2)\times n$个开关，可实现$4^m$种置换连接（每个开关有四种功能）
-  采用$2\times 2$的4功能开关
- 采用单元控制方式

- 级间连接从输入端至输出端依次为Cn,…,C1,C0; 其中，Cn~C1为均匀洗牌置换，C0为恒等置换 
- 采用终端标记寻径
  - 将元端和终端用二进制表示，位数为n，因为输入输出都是$2^n$
  - 0代表向上输出，1代表向下输出
  - 例子
    - 如果$0\to 5$表示为$000\to 101，x_2x_1x_0\to y_2y_1y_0$
    - 经过K2，二进制变为$x_1x_0x_2'$，其中$x_2'=y_2=1$，即变为$001$
    - 如果我们将K2级的开关编号，则去掉最末尾的数，其余的数字可以表示为开关号，即经过K2的标号为00的开关
    - 余下同理，经过$K_i$开关，则$x_i'=y_i$，且其余为到达$K_i$级的开关编号
  - 对于冲突的判断
    - 例如$101\to 100和011\to 101$
    - 经过K2时，第一组开关编号为01，第二组为11，不冲突。第一组变为011，第二组变为111
    - 经过K1时，第一组开关编号为11，第二组也为11，冲突，争用K1级的第四个开关
  - 例：在N=8的Omega网络中采用终端标记寻径法，至少要连接几次才能实现蝶式置换所要求的连接？
    - 发现$0\to 0:000\to 000与4\to 1:100\to 001$在K2时。争用第1个开关
    - 以此类推
    - 第一次实现$0\to 0,1\to 4,2\to 2,3\to 6$，第二次实现$4\to 1,5\to 5,6\to 3,7\to 7$

### STARAN网络

![image-20200802005858337](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802005858337.png)

- $N\times N$共n=log2N级开关，从输入端至输出端依次为K0,K1…,Kn-1采用$2\times 2$的2功能开关，直送和交叉
- 级间连接从输入端至输出端依次为C0, C1,…,Cn; 其中，C1~Cn为逆洗牌置换，C0为恒等置换 
- 每级N/2个开关，共$m=(N/2)log_2N$个开关，共可实现$2^m$种置换连接
- 采用级控方式或组控方式
- 级控方式及交换置换
  - ![image-20200802134102326](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802134102326.png)
  - ![image-20200802133915133](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802133915133.png)
- 组控方式及移数置换
  - 第i级开关分为i+1组
  - ![image-20200802144205648](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802144205648.png)
  - ![image-20200802142503961](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802142503961.png)
  - 例子
    - 移1模8的，即m=0、p=3的解释
    - 在原输入端的二进制的基础上加上001然后模8
    - 记输入$x_2x_1x_0$，输出$y_2y_1y_0$，
    - 控制$x_0$为K0开关，因为加上001后，$x_0$必为交叉状态，所以$f_0$应为1
    - 控制$x_1$为K1开关，因为当前位要不要交叉只在于$x_0$是否发生进位。我们可以发现，当$x_0'=0$时发生进位，$x_0'=1$不发生进位，所以对于$x_0'x_2x_1'$来说，00和01的开关的是交叉，而10和11的开关是直送，所以$f_{11}=1,f_{12}=0$
    - 对于K3来说，只有$x_0=1,x_1=1$的才会进位，$x_2'$才会取反，而$x_211\to 0x_21\to 00x_2$，所以开关号为00的开关是交叉，其余为直送。所以$f_{21}=1,f_{22}=0,f_{23}=0$

### Benes二进制置换网络

 ![image-20200802155910298](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802155910298.png)

- $N\times N$；共$2log_2N=2n$级开关，从输入端至输出端依次为K0,K1…,Kn-1,Kn,…,K2n-1
- 采用$2\times 2$的2功能开关，直送和交叉
- 每级N/2个开关，共$N(log_2N)$个开关 
- $C_1 \backsim C_{n-1}$为逆子洗牌置换 ,$C_{n+1}\backsim C_{2n-1}$为子洗牌置换
-  采用单元控制方式
- 又称为全排列网络，N个输入端和N个输出端的置换连接共有N！种。
- 可以将中间的$K_{n-1}$和$K_{n}$合并
- 左边的走法无关紧要，总是可以通过右边的开关级来修正
- 例子
  - 假设只有一个连接$001\to 100$
    - 由于左边的走法无关紧要，所以左边为$y_0y_1y_2$控制
    - 只要保证右边的走法为`下上上`即可
    - 所以走法为`上上下 下上上`
- 上控法和下控法
  - 上控法是指由到达开关上输入端的终端标记来控制该开关的状态，而到达下输入端的连接只能服从开关状态。下控法相反
  - 如果经过Ki级开关后，采用上控法，导致$x_i'=\overline{y_i}$，则称为产生了**变异**
  - 由于左端的走法无关紧要，只要在右侧对称的位置恢复，如$K_i$与$K_{2n-1-i}$对称，只要让$x_{2n-1-i}''=yi$即可
  - 如果在左侧（$0\leq i\leq n-2$）出现变异，则是可被修正的
  - 如果在$K_{n-1}$级后出现变异，则是不可修正的
  - 变异修正的例子
    - ![image-20200802171450803](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200802171450803.png)
    - $001\to 100$在$K_0$出现变异
    - 正常的走法为`上上下 下上上`
    - 变异导致左侧变为`下上下`
    - 但是在右侧进行了修复，右侧走法仍然为`下上上`

 

 