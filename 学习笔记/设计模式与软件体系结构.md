## 设计模式

### 工厂模式

#### 简单工厂方法模式（静态工厂方法模式）

- 特点
  - 该设计将类的选择和对象的创建封装在**工厂方法**中,而将这个方法封装在**工厂类**里面。

![image-20210617153917094](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210617153917094.png)

- 优点
  - 可通过配置文件，在不更改代码的情况下修改产品类，提高灵活性
- 缺点
  - 违法**开闭原则**，在新增产品时要修改工厂类

#### 工厂方法模式

- 特点
  - 在工厂方法模式中,核心的工厂类不再负责所有产品的创建,而是将具体创建工作交给子类去做。
  - 和简单工厂方法模式的区别在于,在简单工厂方法模式中, Producer是一个单独的类,而工厂方法模式的Producer类已经不是一个单独的类,而是一个层次类

![image-20210617161435052](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210617161435052.png)

- 优点
  - 可以允许系统在不修改工厂角色的情况下引进新产品，符合开闭原则
- 缺点
  - 在添加新产品时,需要编写新的具体产品类,而且还要提供与之对应的具体工厂类,系统中类的个数将成对增加,在一定程度上增加了系统的复杂度
- 简单工厂模式与工厂方法模式的区别:
  - 两个模式的中心不同。
  - 是否支持开闭原则。
  - 创建对象逻辑判断的位置。

#### 抽象工厂方法模式

- 特点
  - 提供一个创建一系列**相关或相互依赖**对象的接口,而无须指定它们具体的类。

![image-20210617170242883](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210617170242883.png)

- 优点
  - 符合开闭原则
  - 当一个产品族中的多个对象被设计成一起工作时,它能够保证客户端始终只使用**同一个产品族**中的对象。
- 缺点
  - 开闭原则的倾斜性(增加新的工厂和产品族容易,增加新的产品等级结构麻烦)
  - 难以扩展抽象工厂来生产新种类的产品

### 生成器模式

- 特点
  - 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
  - 生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
  - 客户端**不直接调用**生成器的相关方法，而是通过**指挥者类**来指导如何生成对象

![image-20210617230237659](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210617230237659.png)

- 优点
  - 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的 创建过程可以创建不同的产品对象
  - 增加新的具体生成器无须修改原有类库的代码，**指挥者类**针对抽象生成器类编程，系统扩展方便，符合 “开闭原则”
- 缺点
  - 如果产品之间的差异性很大，则不适合使用生成器模式，因此其使用范围受到一定的限制
  - 如果产品的内部变化复杂，可能会导致需要定义很多具体生成器类来实现这种变化，导致系统变得很庞大
- **生成器模式**与**抽象工厂模式**
  - 生成器模式返回一个**组装好的**完整产品，而抽象工厂模式返回**一系列相关的**产品，这些产品位于不同的产品等级结构，构成了一个产品族
  - 在**抽象工厂模式**中，**客户端**实例化工厂类，然后调用工厂方法获取所需产品对象，而在**生成器模式**中，客户端**不直接调用**生成器的相关方法，而是通过**指挥者类**来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象
  - 如果将抽象工厂模式看成汽车**配件生产工厂**，生产一个产品族的产品，那么生成器模式就是一个**汽车组装工厂**，通 过对部件的组装可以返回一辆完整的汽车。

### 单例模式

- 特点
  - 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例

![image-20210617234250229](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210617234250229.png)

- 优点
  - 提供了对唯一实例的受控访问
  - 以节约系统资源
  - 允许可变数目的实例
- 缺点
  - 单例类的扩展有很大的困难
  - 单例类的职责过重

### 组合模式

- 特点
  - 组合模式描述了如何将容器对象和叶子对象进行递归组合， 使得用户在使用时**无须对它们进行区分**，可以**一致地对待容器对象和叶子对象**
  -  组合多个对象形成**树形结构**以表示“整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有**一致性**。

![image-20210618105638003](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618105638003.png)

  - 说明 
      - Component：为组合模式中的对象声明接口
      -  Leaf：在组合模式中表示叶结点对象 
      - Composite：表示组合部件 
      - Client：通过Component接口操纵组合部件的对象
- 优点
  - 客户端可以一致的使用组合结构或其中单个对象
  - 更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码
- 缺点
  - 使设计变得更加抽象
  - 很难对容器中的构件类型进行限制

### 适配器模式

- 配置
  - 当客户类调用适配器的方法时，在**适配器类**的**内部**将调用**适配者类**的方法，而这个过程对客户类是透明的，客户类并**不直接访问**适配者类
  - 适配器可以使由于接口不兼容而不能交互的类可以一起工作

![image-20210618111356592](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618111356592.png)

- 优点
  - 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码
  - 增加了类的透明性和复用性
  - 灵活性和扩展性都非常好
- 缺点
  - 对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类

### 外观模式

- 特点
  - 外观模式又称为 外观模式又称为门面模式，它是一种对象结构型模式
  - 用户只需要直接与外观角色交互，用 户与子系统之间的复杂关系由外观角色来实现
  - 在外观模式中，通常只需要一个外观类，并且此外观类**只有一个实例**，换言之它是一个**单例类**
  - **不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的**

![image-20210618113922520](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618113922520.png)

- 优点
  - 根据“单一职责原则”，在软件中将一个系统划分为若干 个子系统有利于降低整个系统的复杂性，一个常见的设计 目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统 的访问提供了一个简单而单一的入口
  - 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子 系统类的耦合度
  - 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复 杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。
- 缺点
  - 外观模式最大的缺点在于**违背了**“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题

### 桥接模式

- 特点
  -  桥接模式将继承关系转换为**关联关系**，从而降低了类与类之间的耦合，减少了代码编写量
  - 将抽象部分与它的实现部分分离，使它们都可以独立地变化

![image-20210618121725349](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618121725349.png)

- 优点
  - 分离抽象接口及其实现部分
  - 桥接模式是比多继承方案更好的解决方法
  - 实现细节对客户透明，可以对用户隐藏实现细节
  - 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
- 缺点
  - 会增加系统的理解与设计难度
  - 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性

### 迭代器模式

- 特点
  - 提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构
  - 迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有
  - 将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代对象中

![image-20210618150102528](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618150102528.png)

- 优点
  - 满足“开闭原则”的要求。当修改某一个遍历算法时不会影响其他的遍历算法。当修改遍历的聚合的结构代码时，如果该聚合的结构没有改变，则相应的遍历算法代码也不需要改变
  - 迭代器简化了聚合的接口
- 缺点
  - 增加新的聚合类需要对应增加新的迭代器类
  - 类的个数成对增加

### 访问者模式

- 特点
  - 封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变
  - 为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，
  - 访问者层次类Visitor与被访问者层次类Element存在关联，并且是双向的关联
    - Element->Visitor：由接受方法 accept( Visitor v) 的参数产生
    - Visitor->Element：由访问者方法 visitElementA( ElementA ) 与visitElementB( ElementB )的参数产生

![image-20210618152926131](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618152926131.png)

- 优点
  - 增加新的访问操作变得很容易
  - 将有关元素对象的访问行为集中到一个访问者对象中
  - 以跨过类的等级结构访问属于不同的等级结构的元素类
  - 让用户能够在不修改现有类层次结构的情况下，定义该类层次结构的操作
- 缺点
  - 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，违背了“开闭原则”的要求
  - 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作

### 中介者模式

- 特点
  - 用一个中介对象来封装一系列的对象交互，中介者使各对象不 需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
  - 中介者模式的要点是将所有对象之间的交互细节抽象到一个独立的类中， 这个类叫做中介者类Mediator

![image-20210618161848102](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618161848102.png)

- 优点
  - 低耦合使得一个类的修改不会影响到其他的类
  - 所有对象的交互行为都被转入到一个独立的中介 者对象中，使得用户更容易通过中介者修改对象之间 的相互关系行为。
- 缺点
  - 在具体中介者类中包含了同事之间的交互细节，可能会导 致具体中介者类非常复杂，使得系统难以维护

### 策略模式

- 特点
  - 策略模 式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理
  - 策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类

![image-20210618172923649](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618172923649.png)

- Context类的作用
  - 作为客户类（Client）和策略类（Strategy）的“传话筒”，将客 户类的请求与由客户类所提供的各种参数传递给策略类。客户类 通常创建并且传递一个ConcreteStrategy的对象给Context。然后客 户类即可和Context类单独交互； 
  - 可以将算法所需要的所有数据传递给策略类； 
  - 可以将自己以参数的形式传递给策略的运算，然后当需要时，让策略类调用Context

- 优点
  - 得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中
  - 将不同算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化
- 缺点
  - 客户程序必须知道不同策略接口的各个子类的行为，必须理解每个子类有哪些不同
  - 客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象

### 状态模式

- 特点
  - 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为
  - 状态模式的关键是引入了一个**抽象类**来专门表示对象的状态，这个类我们叫做**抽象状态类**，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了 不同状态的行为，包括**各种状态之间的转换**

![image-20210618192828893](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210618192828893.png)

- 优点
  - 封装了转换规则
  - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
  - 可以让多个环境对象共享一个状态对象，从而减少系统中 对象的个数
- 缺点
- **策略模式**与**状态模式**
  - **策略模式**的环境类**自己选择**一个具体策略类，具体策略类无须关心环境类；
  - **状态模式**的环境类由于**外在因素**需要放进一个具体状态中， 以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种**双向的关联**关系
  - 使用**策略模式**时，客户端**需要知道**所选的具体策略是哪一个
  - 使用**状态模式**时，客户端**无须关心**具体状态，环境类的状态会根据用户的操作**自动转换**。
  - 两种模式在结构上是相同的。策略模式将每个条件分支封装在一个子类中，而状态模式将每个状态封装在一个子类中
  - 策略模式用来处理一组具有相同目的但是实现方法不同的算法，这些算法方案之间一般来说没有状态变迁，并且用户总是从几个算法中间选取一个
  - 状态模式则不同，它实现的一个概念可以叫做动态继承，也就是继承的子类都可以发生变化。状态的变化可以由一个状态迁徙图表示

## 体系结构

### 调用-返回风格软件体系结构

![image-20210619091245071](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210619091245071.png)

#### 主程序-子程序体系结构

- 特点
  - 设计思想：系统从功能的角度进行设计，从高层开始，逐步细化为详细设计

![image-20210619092246200](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210619092246200.png)

- 优点
- 缺点
  - 功能演化困难
  - 现实中的系统功能不容易描述
  - 功能化设计丢掉了数据与数据结构
  - 功能化设计丢掉了数据与数据结构

#### 面向对象体系结构

- 特点
  - 系统看作由一些对象的集合组成，消息从一个对象发到另一个对象，每个对象都有其相关功能

![image-20210619092428166](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210619092428166.png)

- 优点
  - 容易维护
  - 可复用性好
  - 映射现实世界
  - 容易对一个系统进行剖分
- 缺点
  - 面向对象程序占用内存较大
  - 一个对象要和另外一个对象交互，该对象必须知道另外一个对象的身份， 包括对象名、方法名和参数类型等

- 主程序-子程序体系结构与面向对象体系结构各自使用什么设计方法
  - 主程序-子程序体系结构：采用自顶向下的设计方法。系统从功能的角度进行设计，从高层开始，逐步细化为详细设计。
  - 向对象体系结构：面向对象设计。系统看作由一些对象的集合组成，消息从一个对象发到另一个对象，每个对象都有其相关功能。
- 主程序-子程序与面向对象体系结构的比较
  - 相似之处：两种设计都属于调用 – 返回风格
  - **主程序-子程序体系结构**所产生的程序中，每个软件构件都有一个唯一的 程序执行入口和唯一的程序执行出口，并且当一个构件调用另外一个构件时， 程序运行控制权将转移给被调用的构件，当被调用构件的代码执行完毕以后， 即程序运行至该构件的出口以后，控制被返回给调用的控件
  - **面向对象体系结构**所产生的程序中，当一个对象的方法调用另外一个对 象的方法时，被调用对象将接过程序运行控制，当被调用对象的方法运行完以 后，控制将交还给调用对象

### 数据流风格软件体系结构

![image-20210619095417769](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210619095417769.png)

#### 顺序批处理软件体系结构

- 特点
  - 每个处理程序模块都是互为独立的程序
  - 只有上一步程序彻底完成了，下一步程序才能开始
  - 数据作为一个整体进行传输。
  - 因为以上的特点，所以不必对其组件进行同步处理
  - 因为几个组件只能按照顺序运行，而不能同步运行，所以性能可能比那些能按 照几个组件同时运行的程序要差一些
  - 使用顺序批处理结构设计的软件**不适用**于要求对数据进行**实时处理**的系统。

![image-20210619122453225](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210619122453225.png)

- 优点
- 缺点

#### 管道-过滤器软件体系结构

- 特点

- 优点
- 缺点

### 事件系统软件体系结构

- 特点
- 优点
- 缺点

### 层次软件体系结构

- 特点
- 优点
- 缺点

### MVC软件体系结构

- 特点
- 优点
- 缺点