# java学习

## Java基础

### 枚举类

```java
public enum Test{Test1, Test2};
```

​	上面的声明定义的是一个类，其枚举的每一个值都是该枚举类

的一个实例，不会再构造新的实例。

- 枚举类继承了Enum类，所以不能再继承其他类。而且枚举类是final的，所以不能再被其他类继承。

- 枚举类在经过编译器编译之后产生的还是一个class文件，因此枚举类虽然语法和普遍类差别很大，但是他还是一个类。
- 如果要在枚举类内声明其他成员，要在最后枚举常量结尾加一个分号。
- 枚举没有构造方法，但是可以自定义自己的方法，同样可以定义一个私有的构造方法。

### I/O流

### 多线程与锁

### 注解与反射

## javaWeb

### Cookie与Session

### 重定向与转发

### MVC三层架构

#### 什么是MVC

| Model                                    | view                       | Cntroller                                        |
| ---------------------------------------- | -------------------------- | ------------------------------------------------ |
| 模型                                     | 视图                       | 控制器                                           |
| 业务处理（业务逻辑）、数据持久层（CRUD） | 展示数据、提供链接发起请求 | 接受用户请求、交给业务层对应代码、控制视图层跳转 |

#### 三者之间的关系图

![image-20200607203007137](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607202733624.png)

## MyBatis



## Spring

### Spring是什么

​	Spring是一个轻量级、非入侵的控制反转(IOC)和面向切面编程(AOP)的框架。

### Spring组成

![这里写图片描述](https://gitee.com/lin_haoran/Picgo/raw/master/img/20170713150400373.bmp)

### 什么是IOC

#### 为什么要IOC

​	在没有IOC的程序中，各个对象相互合作，最终实现业务。但是这样导致的各个对象相互耦合在一起，如果其中的一个对象出了问题，其他的对象也不能正常工作。

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/30130748-488045b61d354b019a088b9cb7fc2d73.png)

<center>耦合的对象</center>

​	在引入IOC容器之后，各个对象没有了耦合关系，对象的控制权交给了第三方。

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/30131727-a8268fe6370049028078e6b8a1cbc88f.png)

<center>IOC解耦过程</center>

​	在取出IOC容器后，发现各个对象没有了耦合关系，这样我们可以在编写一个对象的时候不需要考虑其他的对象，各个对象之间的依赖降到最低。

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/30132051-58562511cc6541fdb2636081e455d808.png)

<center>对理想的系统</center>

​	而在放到实际的开发之中，在没有引入IOC之前，对象A依赖对象B，那么在对象A创建运行或运行到某一时刻，必须要主动创建对象B。在这种状态下，创建、控制对象的权力都在程序之中，如果有新的需求，那么就必须要修改程序。

​	而引入IOC之后，我们把创建、控制对象的权力交给第三方，第三方可以自己通过IOC容器来控制对象，也就实现了**控制反转**。

#### IOC本质

​	控制反转IOC(Inversion of Control)是一种设计思想，依赖查找（DL）和依赖注入（DI）是实现IOC的方式。而的控制反转就是：**获得依赖对象的方式反转了**。

### Spring与IOC

​	**IOC是Spring框架的核心内容**。使用多种方式完美实现了IOC，可以使用XML配置，也可以使用注解。

​	Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象，这种实现是**依赖注入**。



### 第一个Spring程序

```java
package com.demo.Hello;
    
public class Hello{
    private String str;
    public String getStr(){
		return str;
    }
    public String setStr(String str){
        this.str = str;
    }
    public String toString(){
        return str;
    }
}
```

```xml
<!--xml配置文件:beans.xml(随意命名)-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd" >
    <!--
		Spring 与 new 一个对象的对比
		id = 变量名
		class = new 的对象
		property = 给对象中属性设置一个值 value:一个具体的值 ref:引用Spring创建好的对象
	-->
    <beab id="hello" class="com.demo.Hello">
    	<property name="str" value="Spring"/>
    </beab>
    
    <!--import 导入配置-->
    <import resource="配置文件"/>
```

```java
//test类
public class Test{
    public static void main(String[] args){
        ApplcationContext context = new ClassPathXmlApplicationContext("beans.xml");
        Hello hello = (Hello) context.getBean("hello");
        //至此获取到了hello对象
    }
}
```

### 对于程序的思考

- Hello对象是谁创建的？

  是由Spring创建的

- Hello对象的属性是怎么设置的？

  是由Spring容器设置的

**这个过程就叫控制反转**

- 控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。
- 反转：程序本身不创建对象，而变成被动的接收对象。
- 依赖注入：就是用set方法来注入的。
- IOC是一种编程实现，由主动的编程变成被动的接收。
- 所有bean在配置文件加载后就被Spring实例化了，默认在内存中每个bean只存在一个实例，是单例模式。

​	使用Spring之后，我们**无需去程序中改动**，要实现不同的操作，只需要在配置文件中进行修改，即**对象由Spring来创建，管理，装配**。

### 依赖注入

```java
package com.demo.Test;
    
public class Test{
    private String name;
    private int age;
    public Test(String name,int age){
        this.name=name;
        this.age=age;
    }
}
```

#### 构造器注入

```xml
<bean id="test" class="com.demo.Test">
	<constructor-arg index="0" value="张三"/>
    <constructor-arg index="1" value="22"/>
</bean>
```

#### Set方式注入

```xml
<bean id="test1"class="com.demo.Test">
</bean>
<bean id="test" class="com.demo.Test">
    <!--例子中的name不是固定类型-->
    <!--普通值注入-->
    <property name="name" value="str"/>
    <!--bean注入-->
    <property name="name" ref="test1"/>
    <!--数组-->
    <property name="name">
    	<array>
        	<value>test1</value>
            <value>test2</value>
            ...
        </array>
    </property>
    <!--List-->
    <property name="name">
    	<list>
        	<value>test1</value>
            <value>test2</value>
            ...
        </list>
    </property>
    <!--Map-->
    <property name="name">
    	<map>
        	<entry key="test1"value="test1"/>
            <entry key="test1"value="test1"/>
            ...
        </map>
    </property>
    <!--Set-->
    <property name="name">
    	<set>
        	<value>test1</value>
            <value>test2</value>
            ...
        </set>
    </property>
    <!--null-->
    <property name="name">
        <null/>
    </property>
    <!--Properties-->
    <property name="name">
    	<props>
        	<prop key="test1">test1</prop>
            <prop key="test2">test2</prop>
            ...
        </props>
    </property>
</bean>
```

#### 拓展方式注入

```xml
<!--p命名空间注入，可以直接注入属性的值:property-->
<bean id="test" class="com.demo.Test" p:name="name" p:age="18"/>
<!--c命名空间注入，通过构造器注入:construct-args-->
<bean id="test" class="com.demo.Test" c:name="name" c:age="18"/>
```

### 自动装配

​	关键字：autowire

```xml
<bean id="test" class="com.demo.Test" autowire="..."/>
```

#### ByName

​	会自动在上下文查找和自己对象set方法后面的值对应的beanid。	

#### ByType

​	会自动在上下文查找和自己对象类型相同的bean。

### 注解实现自动装配

​	jdk1.4支持注解，Spring2.5支持注解。

```xml
<!--
	要使用注解：
	1.导入约束:context
	2.配置注解的支持
-->
	<context:annotation-config/>
```

#### @Autowired

​	表示被修饰的类需要注入对象，可以直接在属性上使用，也可在set上使用。

```java
@Autowired
pirvate Test test;
//优先根据类型进行标注装配，可以忽略set方法。
```

#### @Nullable

​	字段标记这个注解，说明这个字段可以为null。

```java
public void setTest(@Nullable Test test){
    this.test=test;
}
//如果显示定义了Autowired的required为false，说明这个对象为null。否则不许为空。
@Autowired(required = false)
private Test test;
```

#### @Qualifier

​	与@Autowired组合可以按照名字进行装配。

```java
@Autowired()
@Qualifier("test1")
privated Test test;
```

#### @Resource

- 是J2EE的注解。
- 匹配顺序

  1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常.
  2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
  3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
  4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类

```java
@Resouce(name = "...")
//加name属性指定名字进行装配。
```

### Spring注解开发

```xml
<!--指定要扫描的包，这个包下的注解就会生效-->
<context:component-scan base-package="要被扫描的包"/>
```

#### @Component

​	把类注册到spring容器中，Bean实例的名称默认是Bean类的首字母小写，还可以在使用时指定Bean实例的名称。

```java
package com.demo;

//等价于<bean id="test" class="com.demo.Test"/>
@Component
public class Test{
    public String name;
}
```

​	@Component还有3个衍生注解，他们功能上一样，但是对应不同的mvc分层。

- dao:@Repository。
- service:@Service。
- controller:@Controller。

#### @Value

​	用来注入基本类型和String，可以直接在属性上使用，也可在set上使用。

#### @Scope

​	用来设置bean的作用域。

#### xml与注解对比

- xml更加灵活，适用于任何场合，维护简单。

- 注解不是自己的类使用不了，维护相对复杂。

- 最佳实践

  - xml用来管理bean。

  - 注解负责属性注入。

#### @Configuration&@ComponentScan&@Bean

​	用纯java来代替xml配置，也会被注册到容器中。

```java
@Configuration
@ComponentScan("com.demo")
//相当于<context:component-scan base-package="要被扫描的包"/>
public class Config{
    
    /**
      * 注册一个bean，相当于写一个bean标签
      * 这个方法的名字相当于bean标签中的id属性
      * 这个方法的返回值，就相当于bean标签中的class属性
    **/
    @Bean
    public Test getTest(){
        return new Test();
        //要注入bean中的对象。
    }
    
    //使用方法
    public static void main(String[] args){
        ApplicationContext context = new AnnotaationConfigAplicationContext(Config.class);
        Test getTest=(Test) context.getBean("getTest");
    }
}
```

#### @Import

​	用来引入其他的java配置。

### Spring AOP

#### AOP介绍

​	AOP 即 Aspect Oriented Program 面向切面编程。通过预编译和运行期动态代理实现程序功能的统一维护的一种技术。

​	利用AOP横向添加的进去的功能一般与主体业务无关，且复用性高。例如日志记录，性能统计，安全控制，事务处理，异常处理等。

​	将这些比较公用的逻辑从业务主逻辑代码中划分出来，通过分离，我们可以将它们独立到非主导业务逻辑的单独方法中。

- **横切关注点**: 跨越应用程序多个模块的方法或功能。
- **切面(ASPECT)**: 横切关注点被模块化的特殊对象。即,它是一个类。
- **通知(Advice)**: 切面必须要完成的工作。即,它是类中的一个方法
- **目标(Target)**: 被通知对象。
- **代理(Proxy)**: 向目标对象应用通知之后创建的对象。
- **切入点(PointCut)**: 切面通知执行的"地点"的定义。
- **连接点(JoinPoint)**: 与切入点匹配的执行点。

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/uIjQbm.jpg)

#### 使用Spring实现AOP

##### 使用原生Spring API接口实现AOP

| 通知类型     | 连接点               | 实现接口                |
| ------------ | -------------------- | ----------------------- |
| 前置通知     | 方法前               | MethodBeforeAdvice      |
| 后置通知     | 方法后               | AfterReturningAdivce    |
| 环绕通知     | 方法前后             | MethodInterceptor       |
| 异常抛出通知 | 方法抛出异常         | ThrowsAdvice            |
| 引介通知     | 类中增加新的方法属性 | IntroductionInterceptor |

​	目标对象

```java
package com.demo;

public class Test{
    public void sayHello(){}
}
```

​	切面要实现增强接口

```java
package com.demo;

public class AopTest implements MechodBeforeAdvice{
    /** method: 要执行的目标对象的方法
      * args: 参数
      *	target: 目标对象
    **/
    public void before(Method method, Object[] args, Object target) throws Throwable{}
} 
```

​	xml配置

```xml
<!--注册bean-->
<bean id="test" class="com.demo.Test"/>
<bean id="AopTest" class="com.demo.AopTest"/>
<!--配置aop-->
<aop:config>
	<!--配置切入点-->
    <aop:pointcut id="pointcut" expression="execution(* com.demo.Test.*(..))"/>
    <!--执行环绕增加-->
    <aop:advisor advice-ref="AopTest" pointcut-ref="pointcut"/>
</aop:config>
```

​	**execution表达式**

```java
execution(<修饰符模式>？<返回类型模式><方法名模式>(<参数模式>)<异常模式>?);
//除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。
```

​	**示例**

```java
execution(* com.sample.service.impl..*.*(..));
```

- 第一个*代表任意返回类型。
- `com.sample.service.impl..`代表``com.sample.service.impl`下的当前包和子包。
- 第二个*代表任意类。
- 第三个*代表任意方法。
- `(..)`代表任意参数类型。

##### 使用自定义类实现AOP

​	自定义类

```java
package com.demo;

public class AnotherAopTest{
    public void before(..){...}
    public void after(..){...}
} 
```

​	xml配置

```xml
<!--注册bean-->
<bean id="test" class="com.demo.Test"/>
<bean id="anotherAopTest" class="com.demo.AopTest"/>
<!--配置aop-->
<aop:config>
    <!--自定义切面-->
    <aop:aspect ref="anotherAopTest">
    	<!--配置切入点-->
    	<aop:pointcut id="pointcut" expression="execution(* com.demo.Test.*(..))"/>
   		<!--通知-->
    	<aop:before mothod="before" pointcut-ref="pointcut"/>
        <aop:after mothod="after" pointcut-ref="pointcut"/>
    </aop:aspect>
</aop:config>
```

##### 使用注解实现AOP

​	开启注解支持。

```xml
<aop:aspectj-autoproxy/>
```

###### @Aspect

​	标注一个类为切面。

###### @Before

​	标注一个方法为通知目标。

```java
@Before("execution(* * * * *)")
//参数为execution表达式，用来标注配置切入点。
```

###### @After

 	同@Before。

###### @Around

 	同@Before。不同的啊我们可以给定一个参数，代表我们要获取的切入点。

```java
@Around("execution表达式")
public void around(ProceedingJoinPoint jp)throws Throwable{
    ...
    //执行方法
    Object proceed = jp.proceed();
    ...
} 
```

### 声明式事务

#### 事务是什么

​	事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

**事务的ACID原则**

- 原子性
- 一致性
- 隔离性
- 持久性

## Spring Boot

## JVM

### 概述

**Java虚拟机**

![image-20200607205751748](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607205751748.png)

### Java内存区域与内存溢出异常

#### 运行时数据区域

![image-20200608000044625](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607224519737.png)

​	其中方法区、堆、执行引擎和本地库接口是由所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区。

#### 程序计数器

- 线程私有。随线程而生，随线程而灭。

- 用来记录当前线程字节码的行号，字节码解释器通过改变他来选取下一条需要执行的字节码指令。
- 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以每条线程都有一个单独的程序计数器。
- 如果执行的是Java方法，它记录的是正在执行的虚拟机字节码指令的地址。
- 如果执行的是本地(Native)方法，它为空(Undefined)。

#### Java虚拟机栈

- 线程私有。随线程而生，随线程而灭。
- 当每个方法执行时，Java虚拟机都会为它创建一个**栈帧**(Stack Frame)用来存储方法的信息，当方法执行完毕后出栈。
- 存储了包括存储局部变量表、操作数栈、动态连接、方法出口等信息。
- 局部变量表存储了编译器可知的**Java基本类型**。以局部**变量槽(**Slot)为单位。64位长的类型会占用2个变量槽。
- 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
- 一个变量槽实际的占用空间的大小由虚拟机实现。

####  本地方法栈

- 线程私有。随线程而生，随线程而灭。
- 同虚拟机栈类似，区别是保存的不是字节码而是本地方法。

####  Java堆

- 被所有线程共享。
- 在虚拟机启动时创建。
- 唯一目的是存放对象实例。
- 被垃圾收集器管理。
- 可被实现为固定大小，也可为可拓展大小，主流为可拓展大小。

#### 方法区

- 被所有线程共享。
- 用于存储被虚拟机加载的类型信息、常量、静态变量等数据。
- 用堆实现。
- 该区域内存回收主要是针对常量池的回收和类型的卸载。

#### 运行时常量池

- 为方法区的一部分。
- 常量池表用来存储编译期生成的字面量和符号引用，在类加载后存放到常量池中。
- 具有动态性，可以在常量可以在非编译期产生。

#### 对象的创建

1. **Java虚拟机遇到new指令**。
2. **检查类是否存在**。检查指令的参数是否在常量池内定位到一个类的符号引用，检查这个符号引用的类是否被加载、解析、初始化过。若没有则执行类的加载过程。
3. **虚拟机为新生对象分配内存**。分配内存的方法有两种：**指针碰撞**和**空闲列表**，使用那种方法主要看Java堆**是否规整**并且垃圾收集器是否有**空间压缩整理**的能力。同时还要考虑线程安全。
4. 对象进行初始化为零值。
5. 对对象进行设置。如对象是哪个类的实例、对象的GC分带年龄信息等将被存放到对象头中。
6. 执行构造函数。

#### 对象的内存布局

- 分为3部分：对象头、实例数据、对齐填充。
- 对象头包含两类信息：第一类是存储对象自身运行时数据，第二类是类型指针
  - 运行时数据包含如GC分布带、锁状态标志位、线程持有的锁等信息，这些信息被存储在32位或64位的Mark Word中。
  - Java虚拟机通过类型指针来确定对象是哪个类的实例。
- 实例数据是对象存储的有效信息，即文默在代码中定义的各种类型字段。
- 对齐填充是为了满足Java虚拟机要求的对象起始位置必须是8字节的整数倍。

#### 对象的访问定位

- 主流的访问粉丝有使用句柄访问和直接指针两种
- 使用句柄访问，好处是当对象被移动，只会改变句柄中的实例数据指针，而reference不需要修改。

![image-20200608113045602](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113045602.png)



- 使用直接指针访问，好处是节省一次指针定位的时间。

![image-20200608113135243](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113135243.png)

#### 内存溢出实例

- Java堆溢出：

  > Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

- 虚拟机栈和本地方法栈溢出：

  >1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
  >2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

- 方法区和运行时常量池溢出：

  > 运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”。

- 本机直接内存溢出：

  >由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。

### 垃圾收集器与内存分配策略

#### 引用计数器算法

​	该方法的原理是在对象中添加一个引用计数器，当被引用时计数器加一，当引用失效时计数器减一，当计数器为零时，说明对象不可再被引用。

​	该方法的优点是原理简单，判定高效，但是当对象相互引用，形成一个环时，就无法正确的释放空间。

​	主流的Java虚拟机不使用这个方法。

#### 可达性分析算法

​	通过"GC Roots"的根对象为起始节点集，开始向下搜索，走过的路程称为"引用链"。

![image-20200608204207423](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608204207423.png)

​	可被作为GC Roots的对象包括：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 在方法区中类静态属性引用的对象。
- 在方法区中常量引用的对象。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
- 不可达对象要经历两次标记才会被宣告死亡。
  1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。
  2. 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。
  3. 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。


#### 引用

##### 强引用|Strongly Reference

- 是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。
- 被强引用所引用的对象永远不会被垃圾收集器回收。
- Vector类的clear方法是通过把引用赋值为null来实现清理工作。

##### 软引用|Soft Reference

- 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它。
- 在系统将要发生内存溢出异常前，会把被软引用的对象列进回收范围之中进行第二次回收。
- 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。

##### 弱引用|Weak Reference

- 弱引用也是用来描述非必需对象的。
- 当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

##### 虚引用|Phantom Reference

- 虚引用并不影响对象的生命周期。
- 虚引用只是为了能在这个对象被收集器回收时收到一个系统通知。
- 无法通过虚引用来取得一个对象实例 。

#### 回收方法区

- 方法区的垃圾收集主要分为两部分：废弃的常量和不再使用的类型。

- 判定一个常量是否废弃：

  1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

  2. 加载该类的类加载器已经被回收。

  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方
     法。

- 常量池中其他类(接口)、方法、字段的符号引用也与此类似。

#### 垃圾收集算法

##### 标记清除算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，统一回收掉所有被标记的对象。

- 缺点
  - 执行效率不稳定。
  - 内存空间碎片化。

##### 标记复制算法

- 内存被分成大小相等的两块，每次只使用一块。
- 当一块用完，就将存活的对象复制到另一块内存上，然后把已使用的内存空间一次清理掉。
- 实现简单，运行高效。
- 缺点
  - 如果大部分对象存活，复制对象的消耗过大。
  - 可使用的内存缩小一半。

##### 标记整理算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，让存活的对象向内存一端移动。

3. 直接清理掉边界以外的内存。

- 缺点
  - 如果回收时有大量对象存活，移动存活对象开销大。
  - 移动对象的操作要求全程暂停用户应用。

##### 分带收集算法

- 根据内存中对象的存活周期不同，在JVM中一般把内存划分为**新生代**和**老年代**。
- 老年代的特点是每次垃圾收集时只有少量对象需要被回收。
- 新生代的特点是每次垃圾回收时都有大量的对象需要被回收。

- 在新生代一般使用标记复制算法，并且不是按1:1的比例来划分内存。
- 在年老代一般使用的是标记整理算法。

- 创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中。
- 当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。
- **永久代**用来存放class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

#### HotSpot的算法细节实现



# 计算机网络

## 概述

### 网络概述

- **网络**由若干**节点**和链接这些节点的**链路**组成
- 因特网的三个阶段
  - ARPANET向互联网发展
  - 三级结构的因特网：主干网、地区网和校园网
  - 形成多层次ISP结构的因特网：出现了**因特网服务提供者ISP**
- 因特网的组成
  - 边缘部分：由用户直接使用
  - 核心部分：由大量网络和链接网络的路由器组成，为边缘部分提供服务。
- 两种通信方式
  - 客户服务器方式(C/S)：客户端请求，服务器提供服务
  - 对等方式(P2P)：对等连接通信

### 因特网核心部分

- 电路交换
  - 建立连接
  - 通信
  - 释放连接
- 分组交换
  - 长报文划分成短的，固定长度的数据段
  - 每个数据段前加上**首部**
  - 首部包含控制信息
  - 存储转发
  - 优点：
    - 高效：动态分配传输带宽
    - 灵活：以分组为单位和查找路由
    - 迅速：不必建立连接就可发送分组
    - 可靠：保证可靠性的网络协议
  - 缺点
    - 存储转发时排队造成时延
    - 首部增加开销

![image-20200712212936944](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200712212936944.png)

​	传播时延的计算

### 网络的性能

#### 名词

- 比特|bit
- 速率：比特率、数据率
- 带宽：最高的数据率
- 吞吐量：在单位时间通过的数据量

- 发送时延：发送第一个比特到最后一个比特发送完毕的时间 $发送时延=\frac{数据帧长度(比特)}{信道带宽(比特/秒)}$  
- 传播时延：在电路中传输的时延
- 处理时延：交换节点存储转发的时间
- 排队时延：在分组排队经历的时延
- 往返时延：从发送数据方发送数据到发送方收到接收方确认的时延

### 网络协议

- 语法：数据与控制信息的结构或格式
- 语义：需要发出何种控制信息,完成何种动作以及做出何种响应。
- 同步：事件实现顺序的详细说明。
- OSI七层结构
  - 物理层：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层**为上层协议提供了一个传输数据的物理媒体**。
  - 数据链路层：数据链路层**在不可靠的物理介质上提供可靠的传输**。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
  - 网络层：网络层负责**对子网间的数据包进行路由选择**。此外，网络层还可以实现拥塞控制、网际互连等功能。
  - 传输层：第一个端到端，即主机到主机的层次。传输层负责**将上层数据分段并提供端到端的、可靠的或不可靠的传输**。此外，传输层还要处理端到端的差错控制和流量控制问题。
  - 会话层：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
  - 表示层：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。
  - 应用层：为操作系统或网络应用程序提供访问网络服务的接口。
- 五层协议结构
  - 应用层：HTTP、DNS（依靠UDP）、SMTP（依靠TCP）
  - 运输层：TCP、UDP
  - 网络层：IP
  - 数据链路层
  - 物理层
- ![五层协议的体系结构](https://gitee.com/lin_haoran/Picgo/raw/master/img/2999225966-5b5f220d89e9c_articlex)
- **协议**是“水平的”,即协议是控制对等实体之间通信的规则。
- **服务**是“垂直的”,即服务是由下层向上层通过层间接口提供的。

## 物理层

### 一些概念

- 信道：向某一个方向传送信息的媒体
- 单工通信:只能有一个方向的通信而没有反方向的交互。
- 半双工通信：—通信的双方都可以发送信息,但不能双方同时发送
- 全双工通信：通信的双方可以同时发送和接收信息
- 码元：在二进制中，一个bit就是一个马原
- 调幅(AM):载波的振幅随基带数字信号而变化。
- 调频(FM):载波的频率随基带数字信号而变化。
- 调相(PM):载波的初始相位随基带数字信号而变化。

![image-20200719224620021](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200719224620021.png)

### 信道的极限容量

- 码元传输的速率R：又称传码率，波特/秒
- 信息传输的速率R：又称传信率，单位为比特/秒
- 奈氏准则：在无噪声干扰的情况下，码元速率上限，$R_{max}=2B,B$为信道带宽
- 香农的极限传输速率
  - 信道的极限信息传输速率$C=B log_2(1+S/N) bps$
  - B为信道带宽
  - S为信道内所传信号后的平均功率
  - N为信道内的高斯噪声功率
  - S/N为信噪比，信噪比越大，传输速率越高
  - 信噪和S/N之间的换算：$dB=10log10(S/N)$

- 多模光纤：在纤芯中不断全反射
- 单模光纤：在纤芯中不发生反射

![image-20200720210832020](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720210832020.png)

### 信道复用

- 频分复用
  - 在分配到频带后，通信过程中始终占用频带
  - ![image-20200720211102896](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720211102896.png)
  - 缺点：难以实现
- 时分复用|TDM
  - 将时间划分为一段段等长的时分复用帧（TDM帧）
  - 每个用户占用的时隙是**周期性的出现**
  - 所有用户在**不同时间**占用**相同的频带宽度**
  - ![image-20200720211129198](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720211129198.png)
  - 缺点：子信道利用率不高
- 统计时分复用|STDM
  - ![image-20200720212001958](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720212001958.png)

- 波分复用
  - 光的频分复用
- 码分复用|CDMA
  - 用户通过使用特殊挑选的码型，相互不会产生干扰
  - 每个站指派一个唯一的m bit的**码片序列**，如(-1,-1,-1,1,1,-1,1,1)
    - 发送比特1就发送当前码片序列
    - 反射比特0就发送当前码片序列的反码
    - 每个站的码片序列必须相互正交，即规格化内积为0
    - 接收端只需要将**收到的信号**与对应站的**码片序列**计算**内积**，就可以获得对应站发出的信息。
  - ![image-20200720212959502](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720212959502.png)

## 数据链路层

### 一些概念

- 链路：一条从点到点的物理路段，中间没有其他交换节点
- 数据链路：在链路的基础上，加上了通信协议来控制数据传输，比如网卡
- 帧：链路层上传输的数据单位

### 三个要点

- 封装成帧

  - 在一段数据前后后添加首部和尾部
  - 进行帧定界
  - ![image-20200720223746888](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720223746888.png)

- 透明传输

  - 字节计数法
  - 字符填充法：插入转义符
    - ![image-20200720223854349](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720223854349.png)
  - 零比特填充法
    - PPP协议用在 SONET/SDH链路时，只要发现有5个连续1,则立即填入一个0。接收端每当发现5个连续1时,就把这5个连续1后的一个0删除。

- 差错控制

  - 在一段时间内,传输错误的比特占所传输比特总数的比率称为误码率BER( Bit Error rate)，误码率与信噪比有很大的关系。

  - 循环冗余检验|CRC

    - 在发送端,先把数据划分为组。假定每组k个比特。
    - 假设待传送的一组数据M=101001(现在k=6)。我们在M的后面再添加供差错检
      测用的n位冗余码一起发送。
    - 首先,须给定一个(n+1)阶生成多项式P，将其系统的排列称为除数。假设n=3，P为1101
    - 在M后面添加n个0，假设为101001000
    - 得到的(k+n)位的数除，以事先选定好的长度为(n+1)位的**除数**P，得出**商**是Q，而余数是R。
    - 这里除法是用**模二运算**，即采用无进位的二进制加法，恰好为**异或**(XOR)操作
    - 余数R比除数P少1位，即R是n位。
    - 将余数R作为冗余码加在数据M后面发出，共(k+n)位，在这里为10100100
    - 当接收方收到数据后，用收到的数据对P进行模二除法，若余数为0，则认为数据传输无差错

    - ![image-20200720225810868](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720225810868.png)
    - 对于模二除法的另一个例子

    ![image-20200720231347486](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200720231347486.png)

### 数据链路层协议分类

- 点对点信道
  - 使用一对一的点对点通信方式
- 广播信道
  - 使用一对多的广播通信方式
  - 过程复杂

### 点对点协议|PPP

![image-20200721194714011](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721194714011.png)

- 透明传输
  - 当PPP用在同步传输链路时,协议规定采用硬件来完成**零比特填充**(和HDLC的做法
    样)
  - 当PPP用在异步传输时,就使用一种特殊的**字符填充法**。

### CSMA/CD协议

![image-20200721195820654](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721195820654.png)

-  是局域网的数据链路层协议
-  总线上的计算机都可以监听到广播信号，但是只有对应的计算机接受数据，不匹配的计算机则丢弃数据，以此来实现一对一通信。
-  以太网提供的服务的是不可靠交付，即尽最大努力交付
-  出现有差错的数据帧接收端直接丢弃，纠错由高层来决定
-  以太网认为重传的数据帧是一个新的帧

#### 碰撞检测

- 当总线上有多个站在同时发送数据，电压摆动过大，超过阈值就说明出现了“碰撞”。
- 出现碰撞就停止发送，等待随机时间才再次发送。
- ![image-20200721200838036](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721200838036.png)
- 争用期
  - 最先发送数据帧的站,在发送数据帧后至多经过时间2τ(两倍的端到端往返时延
    就可知道发送的数据帧是否遭受了碰撞。
  - 以太网的端到端往返时延2τ称为争用期,或碰撞窗口。

#### 二进制指数类型退避算法

- 发生碰撞的站在停止发送数据后,要推迟一个随机时间才能再发送数据。
- 确定基本退避时间,一般是取为争用期$2\tau$。
- 定义重传次数$k,k\le 10,即k=Min[重传次数,10]$ 
- 从整数集合$[0,1,...,(2^k-1)]$中随机地取出一个数,记为r。重传所需的时延就是r倍的基本
  退避时间。
- 当重传达16次仍不能成功时即丢弃该帧,并向高层报告。

#### 最短有效帧

- 即在争用期$2\tau$内能发送的帧的数据量
- 小于最短有效帧的就是发生了冲突，为无效帧

#### 强化碰撞

- 即在出现碰撞停止发送数据后再继续发送若干比特的人为干扰信号，表明发生了碰撞。
- ![image-20200721202927784](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721202927784.png)

### 以太网的MAC层

- **MAC地址**又称为**硬件地址**、**物理地址**，有48位二进制码。
- 生产厂家保证没有重复的MAC地址
- MAC帧格式有两种标准，常用以太网V2的格式

- ![image-20200721203917607](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721203917607.png)
  - 类型是标记上一层用什么协议，方便MAC层将数据交给上层
- 最小帧间隔：为了使接受端可以及时处理数据。
- 数据链路层传递的是MAC帧

### 拓展的局域网

#### 中继器

- 用来加强信号，是一个信号放大器

#### 集线器

- 本质是一个多端口中继器
- 碰撞域是直接叠加

#### 网桥

- 根据MAC帧的目的地址对收到的数据帧进行转发。
- 利用目的MAC地址判断是否转发
- 碰撞域不叠加

- 转发表
  - ![image-20200721210453267](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721210453267.png)
  - 转发表只保留最新的状态信息
  - 对于表中不存在的地址，则通过所以其他接口转发（广播）
  - 如果存在，则按表中的接口转发（单播）
  - 如果接口是该帧进入网桥的接口，则丢弃这个帧
- 广播风暴
  - 出现拓扑环
  - 可以用STP协议（生成树协议）来生成一棵节点生成树

#### 交换机

- 多接口网桥
- 全双工

#### 虚拟局域网

- 与物理位置无关
- 一个虚拟域网内的机器不会收到其他虚拟局域网的广播
- 虚拟局域网限制了接收广播信息的工作站数,减轻广播风暴的危害
- ![image-20200721212036103](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721212036103.png)

## 网络层

- 网络层只向上提供无连接的、尽最大努力交付的**数据报服务**
- TCP/IP体系
  - 网际协议|IP
  - 地址解析协议|ARP
  - 网际控制报文协议|ICMP
  - 网际组管理协议|IGMP
- **中间设备**又称为中间系统或**中继**(relay)系统。
  - 物理层中继系统:**转发器**(repeater)
  - 数据链路层中继系统:**网桥**或**桥接器**(bridge)。
  - 网络层中继系统:**路由器**(router)
    - 由于历史原因，许多文献将路由器称为网关。
    - 互联网指用路由器进行互联的网络。
  - 网桥和路由器的混合物:**桥路器**（brouter)。
  - 网络层以上的中继系统:**网关**(gateway)。
    - 网关复杂，使用少

### IP地址的编址方法

#### 分类的IP地址

- 最基本的编址方法

- 地址分网络号（net-id）和主机号（host-id）

- ![image-20200721221847061](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200721221847061.png)

- | 网络类别 | 最大网络数 | 第一个可用网络号 | 最后一个可用网络号 |
  | -------- | ---------- | ---------------- | ------------------ |
  | A        | $2^7-2$    | 1                | 126                |
  | B        | $2^{14}-1$ | 128.1            | 191.255            |
  | C        | $2^{21}-1$ | 192.0.1          | 223.255.255        |

- 路由器不同接口上有不同ip地址

#### 子网的划分

- 对基本编址方法的改进
- 划分子网后IP地址就变成了三级结构
- 划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id。
- 子网掩码
  - 通过IP数据报首部**无法判断**源主机或目标主机是否进行**子网划分**
  - 使用子网掩码找出IP地址中的子网部分
  - ![image-20200722210043844](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722210043844.png)

#### 构成超网

- 即无分类编址方法CIDR
- CIDR去除了ABC类地址和划分子网的概念，而使用可变长的**网络前缀**来**代替**网络号和子网号
- CIDR使用**斜线记法**，如128.14.32.0/20，代表前20位是**网络前缀**，12位是**主机号**

### 地址解析协议|ARP

- 不管网络层使用的是什么协议,在实际网络的链路上传送数据帧时,最终还是必须使用硬件地址
- ARP中存有局域网中主机和路由器的IP地址和硬件地址的映射表。
- ARP可以通过IP地址查询硬件地址，然后将硬件地址写入MAC帧。

### IP数据报

![](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722181037577.png)

| 字段名     | 长度（位） | 作用                                                         |
| ---------- | ---------- | ------------------------------------------------------------ |
| 版本       | 4          | 表示IP协议的版本                                             |
| 首部长度   | 4          | 可以表示15个不同的单位长度，每个单位为4字节，所以首部最长可以是60字节 |
| 区分服务   | 8          | 未被使用                                                     |
| 总长度     | 16         | 指整个数据报的长度，单位为字节，因此数据报最长为65535字节。总长度不超过MTU，因为MTU是在数据链路层 |
| 标识       | 16         | 一个计数器，产生数据报的标识                                 |
| 标志       | 3          | 最低位是MF（More Fragment），值为1代表后面还有分片，反之代表这个是最后一个分片。DF（Don’t Fragment），值为0时才允许分片。 |
| 片偏移     | 13         | 表示分片后某片在原分组中的相对位置。单位为8字节<br />![image-20200722194447124](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722194447124.png) |
| 生存时间   | 8          | 记为TTL（Time To Live），代表数据报在网络中可通过路由器数量的最大值 |
| 协议       | 8          | 指出此数据报携带的数据使用何种协议<br />![image-20200722194431600](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722194431600.png) |
| 首部检验和 | 16         | 不使用CRC，而是用简单的计算方法<br />![image-20200722194634384](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722194634384.png) |
| 源地址     | 32         | 代表源地址                                                   |
| 目标地址   | 32         | 代表目标地址                                                 |
| 可选字段   | 可变       | 长度从1到40字节不等                                          |

### IP层转发分组

- 在路由表中，对每一条路由，最主要的是目的网络地址，即下一跳地址
  - ![image-20200722202033234](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722202033234.png)
  - IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次
    的间接交付)。
  - 只有到达最后一个路由器时，才试图向目的主机进行直接交付。
- 默认路由
  - 目的网络如果不在表中，就转发给默认路由
  - ![image-20200722202412234](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722202412234.png)
- 加入子网掩码
  - 由于加入子网掩码后，IP地址并不能唯一的表示网络地址，使用转发分组需要修改
  - 从收到的分组的首部提取目的IP地址D。
  - 先用各网络的子网掩码和D按位与，看是否和相应的网络地址匹配。若匹配，则将分组直接交付，否则就是间接交付，执行下一步。
  - 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器，否则，执行下一步。
  - 对路由表中的每一行的子网掩码和D按位与，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器，否则执行下一步。
  - 若路由表中有一个默认路由,则将分组传送给路由表中所指明的默认路由器，否则转发分组出错

## 运输层

![image-20200722220440307](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722220440307.png)

- 运输层提供端到端的逻辑通信和对报文的差错检测。
- 运输层提供面向连接的**传输控制协议**（TCP）和无连接的**用户数据报协议**（UDP）
- 三类端口
  - 熟知端口：0-1023
  - 登记端口号：1024-49151，使用这个范围端口号必须在IANA登记，防止重复
  - 客户端口号：49152-65535

### 用户数据报|UDP

- UDP是无连接的，尽最大努力交付，面向报文的（无拥塞控制），支持一对一、一对多、多对一和多对多

- UDP仅在IP数据报上添加了端口功能和差错检测功能，开销小

#### 用户数据报格式

![image-20200722221642496](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200722221642496.png)

| 字段名 | 长度（字节） | 作用                                                         |
| ------ | ------------ | ------------------------------------------------------------ |
| 伪首部 | 12           | 在计算检验和时临时，把伪首部和UDP用户数据报连接在一起，伪首部仅仅是为了计算检验和 |

### 传输控制协议|TCP

- TCP是**面向连接的**，**一对一**，**可靠交付**，**全双工通信**，**面向字节流**

#### 套接字|Socket

  - Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面。
  - TCP把连接作为最基本的抽象
  - 每一条TCP连接有两个端点。
  - TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。TCP连接的端点叫做套接字(socket)或插口。
  - 端口号拼接到IP地址即构成了套接字
  - ![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/20190718154523875.png)


#### 停止等待协议

  - 每发送完一个分组就停止发送,等待对方的确认。
  - ![image-20200723175443807](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723175443807.png)

#### 自动重传请求|ARQ

- ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。
- 流水线传输
  - 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。
  - ![image-20200723181327875](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723181327875.png)
- 连续ARQ协议
  - ![image-20200723181043938](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723181043938.png)
- 累计确认
  - 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。
  - 优点
    - 容易实现，即使确认丢失也不必重传。
  - 缺点
    - 不能向发送方反映出接收方已经正确收到的所有分组的信息。
- 一个例子
  - Server 发送80个字节 Part1，seq = 1
  - Server 发送120个字节Part2，Seq = 81
  - Server发送160个字节Part3，Seq = 201，此包由于其他原因丢失
  - Client收到前2个报文段，并发送ACK = 201
  - Server发送140个字节Part4， Seq = 361
  - Server收到Client对于前两个报文段的ACK，将2个报文从窗口中移除，窗口有200个字节的余量
  - 报文3的重传定时器到期，没有收到ACK，进行重传
  - 这个时候Client已经收到报文4，存放在缓冲区中，也不会发送ACK【累计通知，发送ACK就表示3也收到了】，等待报文3，报文3收到之后，一块对3,4进行确认
  - Server收到确认之后，将报文3,4移除窗口，所有数据发送完成

#### TCP可靠通信的具体实现

- TCP连接的每一端都必须设有两个窗口个发送窗口和一个接收窗口。
- TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段。
- TCP两端的四个窗口经常处于动态变化之中。
- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。

#### TCP报文端首部格式

![image-20200723193425610](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723193425610.png)

| 字段名   | 长度（位） | 作用                                                         |
| -------- | ---------- | ------------------------------------------------------------ |
| 源端口   | 16         | 端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 |
| 目的端口 | 16         | 同上                                                         |
| 序号     | 32         | 序号字段的值则指的是本报文段所发送的数据的第一个字节的序号   |
| 确认号   | 32         | 期望对方的下一个报文段的数据的第一个字节的序号               |
| 数据偏移 | 8          | 表示数据开始的地方离TCP段的起始处有多远。实际上就是TCP段首部的长度。 |
| 保留     | 6          | 目前还未使用，应置为0                                        |
| URG      | 1          | 紧急URG，当URG=1 时，表明紧急指针字段有效，该报文优先度高    |
| ACK      | 1          | 确认ACK，只有当 ACK=1时确认号才有效。                        |
| PSH      | 1          | 推送PSH，接收TCP收到PSH=1的报文段，就不必等到缓存满了才交付进程 |
| RST      | 1          | 复位RST，当 RST=1 时，表明 TCP 连接中出错，必须释放连接，然后再重新建立运输连接 |
| SYN      | 1          | 同步SYN，当SYN=1，表示这是一个连接请求或连接接受报文         |
| FIN      | 1          | 终止FIN，当FIN=1，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 |
| 窗口     | 16         | 用来让对方设置发送窗口的依据，单位为字节。                   |
| 检验和   | 16         | 检验和字段检验的范围包括**首部**和**数据**。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 |
| 紧急指针 | 16         | 指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面） |
| 选项     | 可变       | 最大报文段长度MSS。代表缓存所能接受的最大长度<br />窗口扩大选项，3字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16+S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。<br/>时间戳选项，10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。 |
| 填充     | 可变       | 填充为4字节的整数倍                                          |

### 拥塞控制

- 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
- 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 
- 流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。 
- 流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 

![image-20200723210852684](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723210852684.png)

#### 慢开始算法

- 在主机刚刚开始发送报文段时可先设置拥塞窗口cwnd = 1，即设置为一个最大报文段MSS 的数值。
- 在每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加至多一个MSS的数值。
- 用这样的方法逐步增大发送端的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。 

![image-20200723211516105](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723211516105.png)

#### 拥塞避免算法

- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法
- 拥塞避免算法的思路是每经过一个往返时间 RTT 就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。
- 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就要把慢开始门限 ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。
- 然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

![image-20200723212023825](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723212023825.png)

#### 快重传

- 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。 

- 快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 

![image-20200723212344285](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723212344285.png)

#### 快恢复

- 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。
- 接下来不执行慢开始算法，耳塞把cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法

![image-20200723212545086](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200723212545086.png)

### TCP三次握手

- 建立连接时，客户端发送请求到服务器，其首部中的同步位 SYN = 1，并选择序号seq=x，表明传送数据时的第一个数据字节的序号是 x。
- 服务器在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y
- 客户端收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。

![无标题.png](https://gitee.com/lin_haoran/Picgo/raw/master/img/1521080893749167.png)

### TCP四次挥手

- 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

![点击查看源网页](https://gitee.com/lin_haoran/Picgo/raw/master/img/timg)

# 数据库系统概述

## 绪论

### 数据库的基本概念

- 数据
  - 数据的定义：描述事物的符号记录。
  - 数据的特点：数据与其语义是不可分的。
- 数据库(DB)
  - 定义：是**长期存储**在计算机内部、**有组织**的、**可共享**的**大量**数据的集合。
- 数据库管理系统(DBMS)
  - 数据定义功能：提供数据定义语言，定义数据库中的数据对象。
  - 数据操纵功能：提供数据库操纵语言，实现对数据库的基本操作(增删改查)。
  - 数据库的建立和维护功能。
- 数据库系统
  - 定义：在计算机系统中引入数据库后的系统构成。

### 数据模型

在数据库中用数据模型这个工具来**抽象、表示和处理**现实世界中的数据和信息。

#### 两大数据模型

- 概念模型
- 逻辑模型和物理模型

#### 两步抽象

- 现实世界中的客观对象抽象为概念模型。
- 把概念模型转换为某一DBMS支持的数据模型。

#### 组成要素

- 数据结构
- 数据操作
- 完整性约束条件

### 根据数据结构分为三类

- 层次数据库
- 网络数据库
- 关系数据库

### 根据数据模型分为两类

- 关系型数据库
- 非关系型数据库

### 数据库系统的特点

- 数据结构化
- 数据的共享性高，冗余度低，易扩充
- 数据独立性高
  - 数据独立性：是指应用程序和数据结构之间相互独立, 互不影响。
  - 物理独立性：指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了,应用程序不用改变。
  - 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了,用户程序也可以不变。
- 数据由DBMS统一管理和控制

### 三级模式

- 外模式: 又称为子模式或用户模式，面向应用程序，描述用户的数据视图。
- 模式: 又称为逻辑模式，面向数据库设计人员，描述数据的整体逻辑结构。
- 内模式: 又称为存储模式，面向物理上的数据库，描述数据在磁盘中如何存储。

### 二级映像

​	映像是存在于两个相邻模式之间。二级映像是一种规则，规定了映像双方如何进行转换。

- 外模式和概念模式映像体现了逻辑独立性。
- 概念模式和内模式映像体现了物理独立性。

## 关系型数据库

### 概念模型

- 实体：客观存在的东西。
- 属性：实体所具有的某种特性。
  - 属性名
  - 属性值
- 联系：实体与实体之间的联系，有一对一，一对多，多对多。
- 实体型：实体类型，通过实体名及其属性名集合来抽象描述同类实体。
- 实体集：同一类型的实体的集合。

### E-R图

- 实体：用矩形框表示
- 属性：用椭圆框表示，连线将实体与属性连接。
- 联系：用菱形框表示，连线将相关实体连接，在线旁标注联系类型(1:1、1:n、n:m)。

![image-20200625211638420](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200625211638420.png)

### 关系模型

- 关系：一个关系对应通常说的一张表。
- 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
- 元组：表中的一行即为一个元组。
- 主码：表中的某个属性组，它可以唯一确定一个元组。
- 域：指属性的取值范围。
- 分量：元组中的一个属性值。
- 关系模式：关系的描述：关系名(属性1，属性2，...，属性n)。

#### 定义关系模式

| 缩写 | 意义                     |
| ---- | ------------------------ |
| R    | 关系名                   |
| U    | 组成该关系的属性名集合   |
| D    | 属性组U中属性所来自的域  |
| DOM  | 属性向域的映象集合       |
| F    | 属性间的数据依赖关系集合 |

#### 关系模型的组成

- 关系数据结构：数据存储的问题。
- 关系操作集合：所有SQL语句。
- 关系完整性约束：表内数据约束(字段与字段)，表与表之间的约束(外键)。
- 关于完整性更多细节在数据库完整性提到

### 关系完整性

- 实体完整性和参照完整性： 关系模型必须满足的完整性约束条件 称为关系的两个**不变性**，应该由关系系统自动支持。
- 应用领域需要遵循的约束条件，体现了具体领域中的语义约束

#### 实体完整性

- 若属性A是基本关系R的主属性，则属性A不能取空值。
- 实体完整性规则规定基本关系的所有主属性都不能取 空值，而不仅是主码整体不能取空值。

#### 参照完整性

- 外码
  - 设F是基本关系R的一个或一组属性，但不是关系R的码。 如果F与基本关系S的主码Ks相对应，则称F是基本关系R 的外码
  - 基本关系R称为参照关系
  - 基本关系S称为被参照关系或目标关系
- 参照完整性规则
  - 若属性F是基本关系R的外码，它与基本关系S 的主码Ks相对应， 则对于R中每个元组在F上的值必须为：空值(F的每个属性值均为空值)或等于S中的某个元组的主码值。
  - ![image-20200625221842805](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200625221842805.png)

#### 用户自定义完整性

- 针对某一具体关系数据库的约束条件，反映某一 具体应用所涉及的数据必须满足的语义要求。
- 关系模型应提供定义和检验这类完整性的机制， 以便用统一的系统的方法处理它们，而不要由应 用程序承担这一功能。

### 码

#### 候选码

​	若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。 

#### 全码

​	最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码。

#### 主码

​	若一个关系有多个候选码，则选定其中一个为主码。

#### 主属性 

​	候选码的诸属性称为主属性。不包含在任何侯选码中的属性称为非主属性或非码属性。

### 三类关系

- 基本关系：实际存在的表，是实际存储数据的逻辑表示。
- 查询表：查询结果对应的表。
- 视图表：由基本表或其他视图表导出的表，是虚表，不对 应实际存储的数据。

### 专门的关系运算

#### 选择

​	在关系R中选择满足给定条件的元组，记为：$\sigma_F(R)=\{t\in R\and F(t)='true'\}$

#### 投影

​	关系R上的投影是从R中选择出若干属性列组成新的关系，记为：$\Pi_A(R)=\{t[A]|t\in R\}$，其中A为R中的属性列。

#### 连接

​	连接也称为$\theta$连接。

- 等值连接：是在R和S的笛卡尔积中选取A、B属性值相等的元组。
- 自然连接：要求R和S必须有相同的属性组，进行等值连接后去除重复的组。

#### 除运算

​	设关系R除以关系S的结果为关系T，这T包含所有在关系R但不在关系S中的属性及其值且T的元组与S的元组的所有组合都在R中。

**实例**

设计模假设有这么三个关系R、S、RS：

**关系R**

| 学生名 |
| ------ |
| 张三   |
| 李四   |
| 王五   |

**关系S**

| 课程名 |
| ------ |
| 语文   |
| 数学   |

**关系RS**

| 学生名 | 课程名 |
| ------ | ------ |
| 张三   | 语文   |
| 张三   | 数学   |
| 李四   | 语文   |

​	可以看出，关系R代表实体“学生”，关系S代表实体“课程”，关系RS代表学生和课程之间的联系“选课”。
​	R的元组有<张三>、<李四>、<王五>，S的元组有<语文>、<数学>。那么RS中的元组<张三，语文>就意味着R的元组<张三>与S中的元组<语文>有关系；元组<张三，数学>意味着R的元组<张三>与S中的元组<数学>有关系。这样，R中的<张三>与S中所有元组都有联系，所以它是RS÷S的结果之一，也是这个例子中唯一的结果。
所以RS÷S的结果是：

| 学生名 |
| ------ |
| 张三   |

​	而RS÷S的意义是“选修了所有课程的学生”。

## 关系数据库标准语言SQL

| SQL功能  | 动词                 |
| -------- | -------------------- |
| 数据查询 | SELECT               |
| 数据定义 | CREATE,DROP,ALTER    |
| 数据操纵 | INSERT,UPDATE,DELETE |
| 数据控制 | GRANT,REVOKE         |

### 定义|CREATE

#### 定义模式

- CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义子句>|<视图定义子句>|<授权定义子句>]
- 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。

#### 定义表

- CREATE TABLE <表名>

  ​						( <列名> <数据类型> [ <列级完整性约束条件>]

  ​						[，<列名> <数据类型> [<列级完整性约束条件>] ] … 

  ​						[，<表级完整性约束条件>] )

### 删除|DROP

#### 删除模式

- DROP SCHEMA <模式名> <CASCADE|RESTRICT>
- CASCADE(级联)：删除模式的同时把该模式中所有的数据库对象全部删除
- RESTRICT(限制)：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝 该删除语句的执行。

### 修改|ALTER

- ALTER TABLE <表名> 

  ​						[ADD <新列名> <数据类型>[完整性约束] ] 

  ​						[ DROP <完整性约束名>] 

  ​						[ALTER COLUMN<列名><数据类型>]

### 查询|SELECT

#### 基本用法

- SELECT [ALL|DISTINCT] <目标列表达式>

  ​						[，<目标列表达式>] …
  ​						FROM <表名或视图名>[， <表名或视图名> ] … 

  ​						[ WHERE <条件表达式>] 

  ​						[ GROUP BY <列名1> [ HAVING <条件表达式>] ] 

  ​						[ ORDER BY <列名2> [ ASC|DESC ] ]；

| 参数         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| SELECT子句   | 指定要显示的属性列                                           |
| FROM子句     | 指定查询对象(基本表或视图)                                   |
| WHERE子句    | 指定查询条件                                                 |
| GROUP BY子句 | 对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。 |
| HAVING短语   | 筛选出满足指定条件的组                                       |
| ORDER BY子句 | 对查询结果表按指定列值的升序或 降序排序                      |
| DISTINCT     | 结果去重                                                     |

#### SELECT子句

- SELECT子句的<目标列表达式>可以为
  - 算术表达式
  - 字符串常量
  - 函数
  - 列别名
  - ...
- 使用列别名改变查询结果的列标题
  - 列名 as 列别名,
  - 列名 列别名,

#### 选择表中的若干元组

- 消除取值重复的行：如果没有指定DISTINCT关键词，则缺省为ALL。
- DISTINCT短语的作用范围是所有目标列。

#### WHERE子句

![image-20200626205816884](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200626205816884.png)

- 确定集合

  - IN或NOT IN：IN <值表>, NOT IN <值表>

- 字符串匹配

  - LIKE或NOT LIKE： [NOT] LIKE ‘<匹配串>’ [ESCAPE ‘ <换码字符>’]

  - 当匹配模板为固定字符串时，可以用=运算符取代LIKE谓 词，用 != 或 <>运算符取代NOT LIKE谓词

  - %代表任意长度(长度可以为0)的字符串

  - _代表任意单个字符

  - 一个汉字要占两个字符的位置

  - 当用户要查询的字符串本身就含有 % 或 _ 时， 要使用**ESCAPE** '<换码字符>' 短语对通配符进行转义。

    如：WHERE Cname LIKE 'DB**\\**_D' ESCAPE '\\'；

    ESCAPE '\\' 表示“\\”为换码字符

- 涉及空值的查询

  - IS NULL 或 IS NOT NULL
  - "IS"不能用"="代替

- 多重条件查询

  - AND和 OR来联结多个查询条件

#### ORDER BY子句

- SELECT [ALL|DISTINCT] <列名> [, <列名> ]...;

- 可以按一个或多个属性列排序
- 升序ASC，降序DESC，缺省值为升序
- ASC排序列为空值的元组最后显示，DESC反之

#### 聚集函数

- 计数
  - COUNT（[DISTINCT|ALL] *）
  - COUNT（[DISTINCT|ALL] <列名>）
- 求和
  - SUM（[DISTINCT|ALL] <列名>）
- 求平均值
  - AVG（[DISTINCT|ALL] <列名>）
- 求最大值
  - MAX（[DISTINCT|ALL] <列名>）
  - MIN（[DISTINCT|ALL] <列名>）

##### 注意点

- 聚集函数遇到空值时，除COUNT(*)外， 都跳过空值而只处理非空值。
- WHERE字句中是不能用聚集函数作 为条件表达式的。

#### GROUP BY子句

- 聚集函数的作用对象
  - 无分组：作用于整个查询结果
  - 有分组：分别作用于每个组
  - 按指定的一列或多列值分组，值相等的为一组
  - GROUP BY子句的作用对象是查询的中间结果表

#### HAVING子句

##### HAVING与WHERE的区别

| 方面     | WHERE                                                        | HAVING                                                     |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 实质     | 是约束声明                                                   | 是过滤声明                                                 |
| 作用时间 | 在查询数据库的结果返回之前对数据库中的查询条件进行约束，即在结果返回之前起作用 | 在查询数据库的结果返回之后进行过滤，即在结果返回之后起作用 |
| 作用对象 | WHERE子句作用于基表或视图，从中选择满足条件的元组            | HAVING短语作用于组，从中选择满足条件 的组。                |
| 聚合函数 | WHERE先于聚合函数执行，所以后面不能使用聚合函                | HAVING后面可以使用聚合函数                                 |

#### 连接查询

##### 注意点

- 连接条件中的各连接字段类型必须是可比的
- 排序合并法和索引连接(了解原理)

##### 几种连接方式

- 等值连接
  - [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 在WHERE子句中连接
- 自然连接
  - <表名1>.<列名1> = <表名2>.<列名2>
  - 在WHERE子句中连接
  - 等值连接的一种特殊情况，把目标列中重复的属性列去掉。
- 非等值连接
  - 在WHERE子句中连接
  - 连接运算符不为 = 的连接操作
- 自身连接
  - 在WHERE子句中连接
  - 一个表与其自己进行连接
  - 需要给表起别名以示区别且属性要使用前缀来区别
- 内连接
  - 内连接是系统默认的，可以省略INNER关键字。
  - 使用内连接后仍可使用WHERE子句指定条件。
  - 在FROM子句中连接。
  - <表名1>  [INNER] JOIN <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
- 外连接
  - 在FROM子句中连接
  - 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出
  - 左外连接：<表名1>  **LEFT [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 右外连接：<表名1>  **RIGHT [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 完全外连接：<表名1>  **FULL [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
- 交叉连接
  - 在FROM子句中连接
  - 实际为笛卡尔积
  - <表名1>  **JOIN** <表名2> [ON ...]
  - ON语句的执行是在JOIN语句之前的，所以应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。

#### 嵌套查询

- 子查询不能使用ORDER BY子句

##### 嵌套查询求解方法

- 不相关子查询：子查询的查询条件不依赖于父查询
  - 从里到外的求解
- 相关子查询：子查询的查询条件依赖于父查询
  - 先从外层取第一个元组，带入到内层求解，WHERE子句返回结果为真加入结果集，然后取下一个元组以此循环。

##### 几种嵌套查询(搜索样例理解)

- 带有IN谓词的子查询
- 带有比较运算符的子查询
- 带有ANY（SOME）或ALL谓词的子查询
- 带有EXISTS谓词的子查询
  - 一些带EXISTS或NOT EXISTS谓词的子查询不能 被其他形式的子查询等价替换
  - 有带IN谓词、比较运算符、ANY和ALL谓词的 子查询都能用带EXISTS谓词的子查询等价替换
  - 由于带EXISTS量词的相关子查询只关心内层查询是否有返回值，并不需要查具体值，因此其效率并不一定低于其他形式的查询
  - 用EXISTS/NOT EXISTS实现全称量词(难点)
  - 用EXISTS/NOT EXISTS实现逻辑蕴函(难点)

#### 集合查询

##### 集合查询的种类

- 并操作UNION
  - <查询块> UNION <查询块>
  - WHERE <条件语句> OR <条件语句>
- 交操作INTERSECT
  - <查询块> INTERSECT <查询块>
  - WHERE <条件语句> AND <条件语句>
  - WHERE <列名> IN <查询块>
- 差操作EXCEPT
  - <查询块> EXCEPT <查询块>
  - WHERE <列名> NOT IN <查询块>

##### 对集合操作结果的排序

- ORDER BY子句只能用于对最终查询结果排序， 不能对中间结果排序，ORDER BY子句只能出现在最后。
- 对集合操作结果排序时，ORDER BY子句中只能用数字指定排序属性

### 索引|INDEX

#### 索引概述

- 索引由DBA或表的属主建立。
- DBMS会在PRIMARY KEY、UNIQUE上建立索引。
- 索引由DBMS自动维护、自动使用。
- RDBMS中索引一般采用B+树、HASH索引来实现，使用哪一个由RDBMS决定
  - B+树索引具有动态平衡的优点
  - HASH索引具有查找速度快的特点

#### 索引作用(了解)

- 快速找出匹配一个WHERE子句的行。
- 当执行联结时，从其他表检索行。
- 对特定的索引列找出MAX()或MIN()值。
- 如果排序或分组在一个可用键的最左面前缀上进行(例如，ORDER BY key_part_1,key_part_2)，排序或分组一个表。

- 如果所有键值部分跟随DESC，键以倒序被读取。 
- 在一些情况中，一个查询能被优化来检索值，不用咨询数据文件。

- 如果对某些表的所有使用的列是数字型的并且构成某些键的最左面前缀，为了更快，值可以从索引树被检索出来。 

#### 建立索引

- CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名> (<列名> [<次序>] [, <列名> [<次序>] ]…)
- UNIQUE表明此索引的每一个索引值只对应唯一的数据记录
- CLUSTER表示要建立的索引是聚簇索引，也即聚簇索引的索引项顺序与表中记录的物理顺序一致，MySQL里主键就是聚集索引。
- 聚簇索引的适用范围：
  - 很少对基表进行增删操作 
  - 很少对其中的变长列进行修改操作。

#### 删除索引

- DROP INDEX <索引名>

#### KEY与INDEX异同

| 方面                | KEY                               | INDEX                                                        |
| ------------------- | --------------------------------- | ------------------------------------------------------------ |
| 作用                | 约束和索引                        | 仅索引                                                       |
| 实现方式(在mysql下) | 既建立了constraint，又建立了index | 它创建时会在另外的表空间(mysql中的innodb表空间)以一个类似目录的结构存储 |

#### 一些KEY

| 命名        | 作用                                                     |
| ----------- | -------------------------------------------------------- |
| PRIMARY KEY | 约束一个存储主键和唯一性，同时也在此key上建立了一个index |
| UNIQUE KEY  | 约束数据的唯一性，同时也在这个key上建立了一个index       |
| FOREIGN KEY | 约束数据的引用完整性，同时也在这个key上建立了一个index   |

#### 总结

- INDEX的作用就仅仅是索引，而像UNIQUE INDEX中的INDEX，其实只是被当作KEY来看待。

### 数据插入|INSERT

- INSERT INTO <表名> [(<属性列1>[，<属性列2 >…)] VALUES (<常量1> [，<常量2>] …)
- RDBMS在执行插入语句时会检查所插元组是否破坏 表上已定义的完整性规则

#### 插入子查询

- INSERT INTO <表名> [(<属性列1> [，<属性列2>… )] 子查询；
- SELECT子句目标列的值的类型和值的个数与INTO子句匹配。

### 数据修改|UPDATE

- UPDATE <表名> SET <列名>=<表达式>[，<列名>=<表达式>]… [WHERE <条件>]；

### 删除数据|DELETE

- DELETE FROM <表名> [WHERE <条件>]；

### 视图|VIEW

- 虚表，是从一个或几个基本表（或视图）导出的表 
- 只存放视图的定义，不存放视图对应的数据 
- 基表中的数据发生变化，从视图中查询出的数据也随之改变

#### 创建视图

- CREATE VIEW <视图名> [(<列名> [，<列名>]…)]
  AS <子查询> [WITH CHECK OPTION]；
- 子查询不允许含有ORDER BY子句和DISTINCT 短语
- 在对视图进行删改的操作回自动加入子查询语句。
- 对视图进行插入操作，会对插入的值进行判断
  - 如果不符合子查询语句，则拒绝插入
  - 如果没有提供子查询语句的值，则默认为子查询语句的值。

##### 带表达式的视图

- 派生属性称为虚拟列。带虚拟列的视图称为 带表达式的视图。
- 带表达式的视图必须明确定义组成视图的各个属性列名

##### 分组视图

- 用带集函数和GROUP BY子句的查询来定义的视图称为分组视图
- 分组视图必须明确定义组成视图的各个属性列名

#### 删除视图

- DROP VIEW <视图名> [CASCADE(级联删除)]；

#### 视图的可更新性

- 若视图是由两个以上基本表导出的，则此 视图不允许更新。
- 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
- 若视图的字段来自集函数，则此视图不允许更新。
- 若视图定义中含有GROUP BY子句，则此视图不允许更新。
- 若视图定义中含有DISTINCT短语，则此视图不允许更新。
- 若视图定义中有嵌套查询，并且内层查询的FROM子 句中涉及的表也是导出该视图的基本表，则此视图不允许更新。

### 其他关键字

#### 自增长|AUTO_INCREMENT

##### 用法示例

```sql
CREATE TABLE Persons
(
	id int NOT NULL AUTO_INCREMENT,
	PRIMARY KEY (P_Id)
)
```

##### 注意点

- 自增长字段的值从1开始, 每次递增1。
- 自增长字段数据不可以重复, 合适生成唯一的id。
- 自增长字段可以使用null或者default来设置值。
- 自增长字段必须是主键 (primary key)。

### 数据类型

| 数据类型         | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| CHAR(n)          | 长度为n的定长字符串                                          |
| VARCHAR(n)       | 最大长度为n的变长字符串                                      |
| INT              | 长整数（也可以写作INTEGER）                                  |
| SMALLINT         | 短整数                                                       |
| NUMERIC(p,d)     | 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 |
| REAL             | 取决于机器精度的浮点数                                       |
| Double Precision | 取决于机器精度的双精度浮点数                                 |
| FLOAT(n)         | 浮点数，精度至少为n位数字                                    |
| DATE             | 日期，包含年、月、日，格式为YYYY-MM-DD                       |
| TIME             | 时间，包含一日的时、分、秒，格式为HH:MM:SS                   |

## 数据库安全性

- DBA拥有所有对象权限
- 用户拥有自己建立的对象的全部操作权限

### 权限授权|GRANT

- GRANT <权限>[,<权限>]...

  ​						[ON <对象类型> <对象名>]
  ​						TO <用户>[,<用户>]...
  ​						[WITH GRANT OPTION];

- 加上WITH GRANT OPTION可以让权限可传递

- GRANT后可以加

  - ALL PRIVILEGES 全部权限
  - SELECT/INSERT/UPDATE/... 对应权限
  - INSERT(<列名>)/UPDATE(<列名>) 修改指定列的权限

- ON后可以加

  - TABLE <表名> 表的对应权限

- TO后可以加

  - PUBLIC 全体成员对应权限
  - <用户名> 指定用户对应权限

### 权限回收|REVOKE

- REVOKE <权限>[,<权限>]...

  ​						[ON <对象类型> <对象名>]

  ​						FROM <用户>[,<用户>]... [CASCADE];

- 加上CASCADE可以级联回收权限

- 其他与GRANT基本相同

### 权限表(了解)

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/200303-20190623142132456-188693664.jpg)

### 创建数据库模式的权限

- CREATE USER \<用户名>
  [WITH] [DBA | RESOURCE | CONNECT]

| 拥有的权限\可否进行的操作 | CREATE USER | CREATE SCHEMA | CREATE TABLE | 登录\执行数据查询和操纵 |
| ------------------------- | ----------- | ------------- | ------------ | ----------------------- |
| DBA                       | Y           | Y             | Y            | Y                       |
| RESOURCE                  | N           | N             | Y            | Y                       |
| CONNECT                   | N           | N             | N            | 拥有相应权限时可以      |

### 数据库角色

- 数据库角色: 被命名的一组与数据库操作相关的权限
  - 角色是权限的集合
  - 可以为一组具有相同权限的用户创建一个角色
  - 简化授权的过程

#### 创建角色

- 创建角色

  - CREATE ROLE <角色名>

- 给角色授权

  - GRANT <权限> [,<权限>]…

  ​						ON <对象类型>对象名

  ​						TO <角色> [,<角色>] ...

- 角色授权

  - GRANT <角色1> [，<角色2>]…

    ​						TO <角色3> [,<用户1>]

    ​						[WITH ADMIN OPTION]

- 角色回收

  - REVOKE <权限> [,<权限>]…

    ​						ON <对象类型> <对象名>

    ​						FROM <角色> [,<角色>]...

## 数据库完整性

- 数据的**正确性**和**相容性**

### 实体完整性

- 在创建表时使用PRIMARY KEY定义主码

- 对于单属性的码有两种声明方式

  - 定义为列级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT PRIMARY KEY,NAME CHAR(20));
    ```

  - 定义为表级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT,NAME CHAR(20),PRIMARY KEY(ID));
    ```

- 对于多属性的码有一种声明方式

  - 定义为表级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT,NAME CHAR(20),PRIMARY KEY(ID,NAME));
    ```

### 参照完整性

- 在创建表时使用FOREIGN KEY定义外码

- 用REFERENCES指明这些外码参照的主码

  ```sql
    CREATE TABLE EP1(NO1 INT,FOREIGN KEY(NO1) REFERENCES EP(ID) [ON DELETE CASCADE ON UPDATE CASCADE]);
    //设置了级联更新删除
  ```

#### 违约处理

| 被参照表           | 参照表             | 违约处理                 |
| ------------------ | ------------------ | ------------------------ |
| 可能破坏参照完整性 | 插入元组           | 拒绝                     |
| 可能破坏参照完整性 | 修改外码值         | 拒绝                     |
| 删除元组           | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值         | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |

### 用户自定义完整性

#### 属性上的约束条件

- 在创建表时定义`NOT NULL\UNIQUE\CHECK`

  - CHECK可以在括号内加布尔条件,例如

    ```sql
    CREATE TABLE EP
    	(SEX CHAR(2) CHECK(SEX IN ('男','女'))
    	)
    ```

- 违约拒绝执行

#### 元组上的约束条件

- 在创建表时用CHECK定义元组上的约束条件

  ```sql
    CREATE TABLE EP
    	(ID INT,
         SEX CHAR(2),
         CHECK(SEX IN ('男','女') AND ID >=0)
    	)
  ```

- 违约拒绝执行

### 约束|CONSTRAINT

- 约束的主要作用是给与名字便于修改和删除

#### 创建约束

- CONSTRAINT <完整性约束条件名>
  [PRIMARY KEY短语
  |FOREIGN KEY短语
  |CHECK短语]

  ```sql
  CREATE TABLE EP
  	(ID INT CONSTRAINT C1 CHECK(ID >= 0),
       SEX CHAR(2) CONSTRAINT C2 NOT NULL,
       CONSTRAINT SKEY PRIMARY KEY(ID)
  	)
  ```

#### 修改表中的完整性限制

- 用 `ALTER TABLE`修改表中的完整性限制

  ```sql
  ALTER TABLE DROP CONSTRAINT <约束名>;
  ALTER TABLE ADD CONSTRAINT <约束名> <约束条件>;
  ```

### 触发器

- 触发器由**事件驱动**

#### 定义触发器

- CREATE TRIGGER <触发器名>
  {BEFORE | AFTER} <触发事件> ON <表名>
   	FOR EACH {ROW | STATEMENT}
   	[WHEN <触发条件>]
   	<触发动作体>

  | 定义触发器 | 说明                                                         |
  | :--------- | ------------------------------------------------------------ |
  | 创建者     | 表的拥有者                                                   |
  | 表名       | 触发器的目标表                                               |
  | 触发事件   | INSERT\DELETE\UPDATE                                         |
  | 触发器类型 | - 行级触发器,对每个命令仅触发一次 <br />- 语句级触发器,对表进行一次操作就触发一次 |
  | 触发条件   | 布尔值为真触发                                               |
  | 触发动作体 | - 可以是一个匿名SQL过程块<br />- 也可以是已创建的存储过程的调用 |

#### 激活触发器

- 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行
- 一个数据表上可能定义了多个触发器,遵循如下的执行顺序
  - 执行该表上的BEFORE触发器
  - 激活触发器的SQL语句
  - 执行该表上的AFTER触发器

#### 删除触发器

- DROP TRIGGER <触发器名> ON <表名>

## 关系数据理论

- 平凡函数依赖：$X\to Y$，并且$Y\subseteq X$
  - 例如$(Sno,Cno)\to Grade$
- 非平凡函数依赖：$X\to Y$，并且$Y\not \subseteq X$
  - 例如$(Sno,Cno)\to Cno$
- 完全函数依赖：$X\to Y$，并且$X$的任意一个真子集$X'$都有$X'\not \to Y$，则称Y对X完全函数依赖，记作$X\stackrel{F}{\to}Y$。
- 部分函数依赖：$X\to Y$，但是Y不完全函数依赖于X，则称Y对X部分函数依赖，记作$X\stackrel{P}{\to}Y$。
- 传递函数依赖：$X\to Y,(Y\not \subseteq X),Y\not \to X,Y\to Z,Z\not \subseteq Y$，则称Z对X传递函数依赖。

### 范式|NF

- $1NF\supset 2NF \supset 3NF \supset BCNF \supset 4NF\supset 5NF$

- 第一范式|1NF
  - 如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于第一范式。

- 第二范式|2NF
  - 在1NF基础上，消除了非主属性对码的部分函数依赖

- 第三范式|3NF
  - 在2NF基础上，消除了非主属性对码的传递函数依赖

- BC范式|BCNF
  - 在3NF基础上，消除了主属性对码的部分和传递函数依赖

- 第四范式|4NF
  - 在BCNF基础上，消除了非平凡且非函数依赖的多值依赖

## 数据库设计

### E-R图

- 要掌握到题目给出实体、关系，然后依照题目画出er图，同时还要规范化关系模式。
- 结合第七章2ppt

#### 原则

- 属性不能再具有需要描述的性质。即属性必须是不可分的数据项

- 属性不能与其他实体具有联系。联系只能发生在实体之间

  ![image-20200701221227349](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200701221218127.png)

#### E-R图向关系模型转换

- 将E-R图转换为关系模型：将实体、实体的属性和实体之间的联系转换为关系模式。
- 1：1联系
  - 转换为一个独立的关系模式
  - 与某一端实体类对应的关系模式合并
- 1：n联系
  - 转换为一个独立的关系模式
  - 与n端对应的关系模式合并
- m：n联系
  - 转换为一个独立的关系模式
  - 例如`选修`是一个n：m关系模式，可以转换为学号与课程号为关系的组合码：选修(<span style="border-bottom:1px solid;">学号</span>，<span style="border-bottom:1px solid;">课程号</span>，成绩)
- 三个及以上的实体的多元联系
  - 转换为一个关系模式
- 有相同码的关系模式
  - 直接合并

#### 数据模型优化

- 用规范化理论为指导进行优化。

### 数据库的物理设计

#### DBMS常用存取方法

- 索引方法
  - B+树索引方法
  - 经典存取方法
- 聚簇方法
- HASH方法

#### 索引

- 选择索引存取的规则
  - 如果一个(或一组)属性经常在查询条件中出现,则考虑在这个(或这组)属性上建立索引(或组合索引)
  - 如果一个属性经常作为最大值和最小值等聚集函数的参数,则考虑在这个属性上建立索引
  - 如果一个(或一组)属性经常在连接操作的连接条件中出现,则考虑在这个(或这组)属性上建立索引

#### 聚簇

- 为了提高某个属性(或属性组)的查询速度,把这个或这止属性(称为聚簇码)上具有相同值的元组集中存放在连续物理块称为聚簇
- 聚簇的优点
  - 提高查询效率
  - 节省存储空间
- 聚簇的缺点
  - 只能提提高某些特定应用的性能
- 聚簇的适用范围
  - 可以用于单个关系的独立聚簇，也可以用于多关系的组合聚簇
  - 当通过聚簇码进行访问或连接是该关系的主要应用,与聚簇码无关的其他访问很少或者是次要的时,可以使用聚簇。
  - 尤其当SQL语句中包含有与聚簇码有关的 ORDER BY,GROUP BY,UNON, DISTINCT等子句或短语时,使用聚簇特别有利,可以省去对结果集的排序操作
- 优化聚簇
  - 从聚簇中删除经常进行全表扫描的关系;
  - 从聚簇中删除更新操作远多于连接操作的关系;
  - 不同的聚簇中可能包含相同的关系，关系可以在某个聚簇中,但不能同时加入多个聚簇
    - 从这多个聚簇方案(包括不建立聚簇)中选择一个较优的,即在这个聚簇上运行各种事务的总代价最小

#### HASH

- 当一个关系满足下列两个条件时,可以选择HASH存取
  方法
  - 该关系的属性主要出现在等值连接条件中或主要出现在相等比较选择条件中该关系的大小可预知,而且不变;
  - 该关系的大小动态改变,但所选用的DBMS提供了动态HASH存取方法

## 关系查询处理和查询优化

### 连接操作实现方法

- nested loop

- sort-merge join
- index join

- hash join

### 查询操作优化

- 关系代数表达式等价变换规则
- 查询树的启发式优化

## 数据库恢复技术

### 事务

#### 定义

- 一个数据库操作序列
- 一个不可分割的工作单位
- 恢复和并发控制的基本单位

#### 事务和程序区别

- 在关系型数据库中,一个事务可以是一条或多条SQL语句,也可以包含一个或多个程序
- 一个程序通常包含多个事务

#### 定义事务的范式

- 显式定义

  - ```sql
    BEGIN TRANSACTION
    	SQL 语句
    	SQL 语句
    	...
    COMMIT
    
    BEGIN TRANSACTION 
    	SQL 语句
    	SQL 语句
    	...
    ROLLBACK
    ```

- 隐式定义

  - DBMS按缺省规定自动划分事务

事务特性|ACID

- 原子性
- 一致性
- 隔离性
- 持续性

### 恢复的实现技术

#### 静态转储

- 在系统中无运行事务时进行的转储操作
- 转储开始时数据库处于一致性状态
- 转储期间不允许对数据库的任何存取、修改活动
- 得到的一定是一个数据一致性的副本
  - 优点:实现简单
  - 缺点:降低了数据库的可用性
- 转储必须等待正运行的用户事务结束
- 新的事务必须等转储结束

#### 动态转储

- 转储操作与用户事务并发进行
- 转储期间允许对数据库进行存取或修改
- 优点
  - 不用等待正在运行的用户事务结東
  - 不会影响新事务的运行
- 动态转储的缺点
  - 不能保证副本中的数据正确有效
- 利用动态转储得到的副本进行故障恢复
  - 需要把动态转储期间各事务对数据库的修改活动登记下来,建立日志文件
  - 后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态

#### 海量转储

- 每次转储全部数据库
- 从恢复角度看,使用海量转储得到的后备副本进行恢复往往更方便

#### 增量转储

- 只转储上次转储后更新过的数据
- 如果数据库很大,事务处理又十分频繁,增量转储方式更实用更有效

#### 以记录为单位的日志

- 内容
  - 各个事务的开始标记
  - 各个事务的结束标记
  - 各个事务的所有更新操作
  - 事务标示，标明是哪个事务
  - 操作类型，插入、删除或秀给
  - 操作对象
  - 更新前数据旧值
  - 更新后数据新值
- 静态转储副本和日志文件进行恢复
  - ![image-20200704144057842](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704144057842.png)
  - 必须先写日志文件，后写数据库

### 事务故障的恢复

- 定义：事务在运行至正常终止点前被终止
- 恢复方法
  - 由恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进行的修改
- 事务故障的恢复由系统自动完成,对用户是透明的,不需要用户干预
- 恢复步骤
  - 反向扫描文件日志(即从最后向前扫描日志文件)查找该事务的更新操作。
  - 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。
    - 插入操作,“更新前的值”为空,则相当于做删除操作
    - 删除操作,“更新后的值”为空,则相当于做插入操作
    - 若是修改操作,则相当于用修改前值代替修改后值
  - 继续反向扫描日志文件,查找该事务的其他更新操作,并做同样处理
  - 如此处理下去,直至读到此事务的开始标记,事务故障恢复就完成了

### 系统故障的恢复

- 系统故障造成数据库不一致状态的原因
  - 未完成事务对数据库的更新已写入数据库
  - 已提交事务对数据库的更新还留在缓冲区没来得及写入数据库
- 恢复方法
  - Undo故障发生时未完成的事务
  - Redo已完成的事务
- 系统故障的恢复由系统在重新启动时自动完成,不需要用户干预

### 介质故障的恢复

- 重装数据库
- 重做已完成的事务

### 具有检查点的数据恢复

- 在日志文件中增加检查点记录
- 增加重新开始文件
- 恢复子系统在登录日志文件期间动态地维护日志

![image-20200704153118097](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704153118097.png)

![image-20200704153305646](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704153305646.png)

## 并发控制

- 并发控制机制的任务
  - 对并发操作进行正确调度
  - 保证事务的隔离性
  - 保证数据库的一致性

- 并发操作带来的数据不一致性
  - 丢失修改( Lost Update)
  - 不可重复读( Non-repeatable Read)
  - 读“脏”数据( Dirty Read)

### 封锁

- 并发控制的主要技术
  - 有封锁( Locking)
    - 排他锁（写锁）
    - 共享锁（读锁）
  - 时间戳( Timestamp)
  - 乐观控制法
- 活锁和死锁
  - 活锁是指事务插队导致有的事务永远无法获取资源
  - 死锁是指相互等待对方释放资源，形成死锁

### 并发调度的可串行性

- 可串行化( Serializable)调度
  - 多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行这些事务时的结果相同
- 可串行性( Serializability)
  - 是并发事务正确调度的准则
  - 一个给定的并发调度,当且仅当它是可串行化的才认为是正确调度
- 可串行化调度的充分条件
  - 一个调度Sc在保证冲突操作的次序不变的情况下,通过交换两个事务不冲突操作的次序得到另一个调度Sc,如果Sc是串行的,称调度Sc为冲突可串行化的调度
  - 一个调度是冲突可串行化,一定是可串行化的调度

### 两段锁协议

​	指所有事务必须分两个阶段对数据项加锁和解锁

- 在对任何数据进行读、写操作之前,事务首先要获得对该数据的封锁
- 在释放一个封锁之后,事务不再申请和获得任何其他封锁
- 两端的含义
  - 第一阶段是获得封锁,也称为扩展阶段。事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁
  - 第二阶段是释放封锁,也称为收缩阶段。事务可以释放任何数据项上的任何类型的锁,但是不能再申请任何锁

## 数据库调优



# 设计模式

## OPP七大原则

- **开闭原则**：对扩展开放，对修改关闭。

- **里氏替换原则**：继承必须确保超类所拥有的性质在子类中仍然成立。

- **依赖倒置原则**：要面向接口编程，不要面向实现编程。

- **单一职责原则**：控制类的粒度大小、将对象解耦、提高其内聚性。

- **接口隔离原则**：要为各个类建立它们需要的专用接口。

- **迪米特法则**：只与你的直接朋友交谈，不跟"陌生人"说话。

- **合成复用原则**：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

## 单例模式|Singleton

- 单例模式只能由一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

### 饿汉式(推荐)

- 在类内创建静态的实例。

- 构造方法私有。

- 通过静态get方法来获取实例。

- 优点：类加载到内存后，就实例化一个单例，JVM保证线程安全

- 缺点：不管用到与否，类装载时就完成实例化。

### 懒汉式

- 在get方法内创建实例。
- 线程不安全。

### 再优化

- 加同步锁。

```java
//volatile来防止JIT时语句重排出现问题。
private static volatile Test INSTANCE;
//双重检查来减少上锁的次数
public static Test getInstance(){
    if(INSTANCE == null){
        synchronized(Test.class){
            if(INSTANCE == null){
                INSTANCE = new Test();
            }
        }
    }
    return INSTANCE;
}
```

### 静态内部类方式实现

```java
public class Test{
    private Test(){}
    //在外部类加载的时候，内部类不会加载。
    private static class TestHolder{
        private final static Test INSTANCE = new Test();
    }
    //内部类在被调用时被加载，由JVM保证线程安全。
    public static void getInstance(){
        return TestHolder.INSTANCE;
    }
}
```

### 枚举单例(完美)

```java
//不仅解决线程同步，还可以防止反序列化。
//因为枚举类没有构造方法，而通过反射可以把类反序列化来把类实例化
public enum Test{
    INSTANCE;
    public void m(){}
}
```

## 策略模式|Strategy



## 代理模式|Proxy

- 在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
- 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

- 代理模式的优点

  - 职责清晰

  - 高拓展性
  - 智能化

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/8493217-06886049700e73f7.png)

<center>代理模式<center/>


### 静态代理

- 角色分析：
  - 抽象角色：一般使用接口或抽象类来解决。
  - 真实角色：被代理的角色
  - 代理角色：代理真实角色，拓展真实角色的功能。

- 代理类和被代理类应实现同一个接口，或是共同继承某个接口。
- 代理模式可以在不修改被代理对象的基础上，通过代理类来拓展一些被代理类没有的功能。
- 代理模式的优点
  - 可以使真实角色的操作更纯粹，不要关注公共业务。
  - 公共业务就交给代理角色。实现业务分工。
  - 公共业务发生拓展时，方便集中管理。

- 代理模式的缺点：
  - 因为真实角色和代理角色实现了相同接口，必须实现相同方法，代码冗余，如果接口增加方法，两者都要实现方法，代码难以维护。
  - 一个代理角色只服务一个接口，代码量大。

### 动态代理

- 动态代理是在运行时，通过反射实现动态代理。

- 动态代理有三种实现方法

  - 基于接口：JDK原生实现
  - 基于类：cglib
  - 基于java字节码：javasist

  要基于接口来实现动态代理，需要了解一个类和一个接口：Proxy类和InvocationHandler接口

#### Proxy

​	**Proxy提供了创建动态代理类的静态方法。**

`java.lang.reflect.Proxy`类的定义：

```java
public class Proxy implements java.io.Serializable {
    ...
    @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    ...
}
```

- ClassLoader loader: 类加载器
- Class<?>[] interfaces: 得到全部的接口
- InvocationHandler h: 得到InvocationHandler接口的子类实例

#### InvocationHandler

​	InvocationHandler是由代理实例的**调用处理程序**实现的接口。

`java.lang.reflect.InvocationHandler`接口的定义：

```java
package java.lang.reflect;
public interface InvocationHandler {
    ...
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

- Object proxy: 被代理的对象。
- Method method: 要调用的方法。
- Object[] args: 方法调用时所需要的参数。

#### 实例

```java
package com.demo;

import ...

public class ProxyInvocationHandler implements InvocationHandler{
    
    //目标对象
    private Object target;
    
    public void setTarget(Object target){
        this.target = target;
    }
    //生成得到的代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getIntterfaces(), this);
    }
    
    //处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        
        //预处理
        ...
            
        //调用目标的方法，返回被调用的目标方法的返回值
        Object result = method.invoke(taret, args);
        
        //后处理 
        ...   
        
        return result;
    }
    
    /***************使用方法*******************/
    public static void main(String[] args){
        
        //真实角色
        Test test= new TestImpl();
        
        //代理角色(通过ProxyInvocationHandler类动态生成)
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        
        //通过调用程序处理处理角色来处理我们要调用的接口对象
        pih.setTarget(test);
        Test proxy = (Test) pih.getProxy();
        proxy.sayHello();//假定Test有一个sayHello方法
    }
}
```



#### 总结

- 动态代理类是一个用来生成代理类的类。
- 一个动态代理类可以代理多个类，只要是实现了同一个接口。
- 解决了静态代理的缺点。

## 工厂模式|Fectory

# 杂项

## 函数式编程

​	**函数式编程关心数据的映射，命令式编程关心解决问题的步骤**

​	展开来说"函数式编程"中的"函数"指的是像数学中的"函数"，只关心数据之间的变换关系，而命令式编程更注重要怎么做才能解决问题。

>		函数式编程的本质
>			函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。

​	函数式编程理论上可以不用任何变量，函数式编程的好处就是不依赖也不修改外部状态。

​	Java 8引进的lambda表达式就是函数式编程特性的体现，lambda表达式允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用lambda表达式可以使代码变得更加简洁紧凑。

```
示例演示：
 (参数) -> 表达式
```

