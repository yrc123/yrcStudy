# 数据库系统概述

## 绪论

### 数据库的基本概念

- 数据
  - 数据的定义：描述事物的符号记录。
  - 数据的特点：数据与其语义是不可分的。
- 数据库(DB)
  - 定义：是**长期存储**在计算机内部、**有组织**的、**可共享**的**大量**数据的集合。
- 数据库管理系统(DBMS)
  - 数据定义功能：提供数据定义语言，定义数据库中的数据对象。
  - 数据操纵功能：提供数据库操纵语言，实现对数据库的基本操作(增删改查)。
  - 数据库的建立和维护功能。
- 数据库系统
  - 定义：在计算机系统中引入数据库后的系统构成。

### 数据模型

在数据库中用数据模型这个工具来**抽象、表示和处理**现实世界中的数据和信息。

#### 两大数据模型

- 概念模型
- 逻辑模型和物理模型

#### 两步抽象

- 现实世界中的客观对象抽象为概念模型。
- 把概念模型转换为某一DBMS支持的数据模型。

#### 组成要素

- 数据结构
- 数据操作
- 完整性约束条件

### 根据数据结构分为三类

- 层次数据库
- 网络数据库
- 关系数据库

### 根据数据模型分为两类

- 关系型数据库
- 非关系型数据库

### 数据库系统的特点

- 数据结构化
- 数据的共享性高，冗余度低，易扩充
- 数据独立性高
  - 数据独立性：是指应用程序和数据结构之间相互独立, 互不影响。
  - 物理独立性：指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了,应用程序不用改变。
  - 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了,用户程序也可以不变。
- 数据由DBMS统一管理和控制

### 三级模式

- 外模式: 又称为子模式或用户模式，面向应用程序，描述用户的数据视图。
- 模式: 又称为逻辑模式，面向数据库设计人员，描述数据的整体逻辑结构。
- 内模式: 又称为存储模式，面向物理上的数据库，描述数据在磁盘中如何存储。

### 二级映像

​	映像是存在于两个相邻模式之间。二级映像是一种规则，规定了映像双方如何进行转换。

- 外模式和概念模式映像体现了逻辑独立性。
- 概念模式和内模式映像体现了物理独立性。

## 关系型数据库

### 概念模型

- 实体：客观存在的东西。
- 属性：实体所具有的某种特性。
  - 属性名
  - 属性值
- 联系：实体与实体之间的联系，有一对一，一对多，多对多。
- 实体型：实体类型，通过实体名及其属性名集合来抽象描述同类实体。
- 实体集：同一类型的实体的集合。

### E-R图

- 实体：用矩形框表示
- 属性：用椭圆框表示，连线将实体与属性连接。
- 联系：用菱形框表示，连线将相关实体连接，在线旁标注联系类型(1:1、1:n、n:m)。

![image-20200625211638420](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200625211638420.png)

### 关系模型

- 关系：一个关系对应通常说的一张表。
- 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
- 元组：表中的一行即为一个元组。
- 主码：表中的某个属性组，它可以唯一确定一个元组。
- 域：指属性的取值范围。
- 分量：元组中的一个属性值。
- 关系模式：关系的描述：关系名(属性1，属性2，...，属性n)。

#### 定义关系模式

| 缩写 | 意义                     |
| ---- | ------------------------ |
| R    | 关系名                   |
| U    | 组成该关系的属性名集合   |
| D    | 属性组U中属性所来自的域  |
| DOM  | 属性向域的映象集合       |
| F    | 属性间的数据依赖关系集合 |

#### 关系模型的组成

- 关系数据结构：数据存储的问题。
- 关系操作集合：所有SQL语句。
- 关系完整性约束：表内数据约束(字段与字段)，表与表之间的约束(外键)。
- 关于完整性更多细节在数据库完整性提到

### 关系完整性

- 实体完整性和参照完整性： 关系模型必须满足的完整性约束条件 称为关系的两个**不变性**，应该由关系系统自动支持。
- 应用领域需要遵循的约束条件，体现了具体领域中的语义约束

#### 实体完整性

- 若属性A是基本关系R的主属性，则属性A不能取空值。
- 实体完整性规则规定基本关系的所有主属性都不能取 空值，而不仅是主码整体不能取空值。

#### 参照完整性

- 外码
  - 设F是基本关系R的一个或一组属性，但不是关系R的码。 如果F与基本关系S的主码Ks相对应，则称F是基本关系R 的外码
  - 基本关系R称为参照关系
  - 基本关系S称为被参照关系或目标关系
- 参照完整性规则
  - 若属性F是基本关系R的外码，它与基本关系S 的主码Ks相对应， 则对于R中每个元组在F上的值必须为：空值(F的每个属性值均为空值)或等于S中的某个元组的主码值。
  - ![image-20200625221842805](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200625221842805.png)

#### 用户自定义完整性

- 针对某一具体关系数据库的约束条件，反映某一 具体应用所涉及的数据必须满足的语义要求。
- 关系模型应提供定义和检验这类完整性的机制， 以便用统一的系统的方法处理它们，而不要由应 用程序承担这一功能。

### 码

#### 候选码

​	若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。 

#### 全码

​	最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码。

#### 主码

​	若一个关系有多个候选码，则选定其中一个为主码。

#### 主属性 

​	候选码的诸属性称为主属性。不包含在任何侯选码中的属性称为非主属性或非码属性。

### 三类关系

- 基本关系：实际存在的表，是实际存储数据的逻辑表示。
- 查询表：查询结果对应的表。
- 视图表：由基本表或其他视图表导出的表，是虚表，不对 应实际存储的数据。

### 专门的关系运算

#### 选择

​	在关系R中选择满足给定条件的元组，记为：$\sigma_F(R)=\{t\in R\and F(t)='true'\}$

#### 投影

​	关系R上的投影是从R中选择出若干属性列组成新的关系，记为：$\Pi_A(R)=\{t[A]|t\in R\}$，其中A为R中的属性列。

#### 连接

​	连接也称为$\theta$连接。

- 等值连接：是在R和S的笛卡尔积中选取A、B属性值相等的元组。
- 自然连接：要求R和S必须有相同的属性组，进行等值连接后去除重复的组。

#### 除运算

​	设关系R除以关系S的结果为关系T，这T包含所有在关系R但不在关系S中的属性及其值且T的元组与S的元组的所有组合都在R中。

**实例**

设计模假设有这么三个关系R、S、RS：

**关系R**

| 学生名 |
| ------ |
| 张三   |
| 李四   |
| 王五   |

**关系S**

| 课程名 |
| ------ |
| 语文   |
| 数学   |

**关系RS**

| 学生名 | 课程名 |
| ------ | ------ |
| 张三   | 语文   |
| 张三   | 数学   |
| 李四   | 语文   |

​	可以看出，关系R代表实体“学生”，关系S代表实体“课程”，关系RS代表学生和课程之间的联系“选课”。
​	R的元组有<张三>、<李四>、<王五>，S的元组有<语文>、<数学>。那么RS中的元组<张三，语文>就意味着R的元组<张三>与S中的元组<语文>有关系；元组<张三，数学>意味着R的元组<张三>与S中的元组<数学>有关系。这样，R中的<张三>与S中所有元组都有联系，所以它是RS÷S的结果之一，也是这个例子中唯一的结果。
所以RS÷S的结果是：

| 学生名 |
| ------ |
| 张三   |

​	而RS÷S的意义是“选修了所有课程的学生”。

## 关系数据库标准语言SQL

| SQL功能  | 动词                 |
| -------- | -------------------- |
| 数据查询 | SELECT               |
| 数据定义 | CREATE,DROP,ALTER    |
| 数据操纵 | INSERT,UPDATE,DELETE |
| 数据控制 | GRANT,REVOKE         |

### 定义|CREATE

#### 定义模式

- CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义子句>|<视图定义子句>|<授权定义子句>]
- 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。

#### 定义表

- CREATE TABLE <表名>

  ​						( <列名> <数据类型> [ <列级完整性约束条件>]

  ​						[，<列名> <数据类型> [<列级完整性约束条件>] ] … 

  ​						[，<表级完整性约束条件>] )

### 删除|DROP

#### 删除模式

- DROP SCHEMA <模式名> <CASCADE|RESTRICT>
- CASCADE(级联)：删除模式的同时把该模式中所有的数据库对象全部删除
- RESTRICT(限制)：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝 该删除语句的执行。

### 修改|ALTER

- ALTER TABLE <表名> 

  ​						[ADD <新列名> <数据类型>[完整性约束] ] 

  ​						[ DROP <完整性约束名>] 

  ​						[ALTER COLUMN<列名><数据类型>]

### 查询|SELECT

#### 基本用法

- SELECT [ALL|DISTINCT] <目标列表达式>

  ​						[，<目标列表达式>] …
  ​						FROM <表名或视图名>[， <表名或视图名> ] … 

  ​						[ WHERE <条件表达式>] 

  ​						[ GROUP BY <列名1> [ HAVING <条件表达式>] ] 

  ​						[ ORDER BY <列名2> [ ASC|DESC ] ]；

| 参数         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| SELECT子句   | 指定要显示的属性列                                           |
| FROM子句     | 指定查询对象(基本表或视图)                                   |
| WHERE子句    | 指定查询条件                                                 |
| GROUP BY子句 | 对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。 |
| HAVING短语   | 筛选出满足指定条件的组                                       |
| ORDER BY子句 | 对查询结果表按指定列值的升序或 降序排序                      |
| DISTINCT     | 结果去重                                                     |

#### SELECT子句

- SELECT子句的<目标列表达式>可以为
  - 算术表达式
  - 字符串常量
  - 函数
  - 列别名
  - ...
- 使用列别名改变查询结果的列标题
  - 列名 as 列别名,
  - 列名 列别名,

#### 选择表中的若干元组

- 消除取值重复的行：如果没有指定DISTINCT关键词，则缺省为ALL。
- DISTINCT短语的作用范围是所有目标列。

#### WHERE子句

![image-20200626205816884](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200626205816884.png)

- 确定集合

  - IN或NOT IN：IN <值表>, NOT IN <值表>

- 字符串匹配

  - LIKE或NOT LIKE： [NOT] LIKE ‘<匹配串>’ [ESCAPE ‘ <换码字符>’]

  - 当匹配模板为固定字符串时，可以用=运算符取代LIKE谓 词，用 != 或 <>运算符取代NOT LIKE谓词

  - %代表任意长度(长度可以为0)的字符串

  - _代表任意单个字符

  - 一个汉字要占两个字符的位置

  - 当用户要查询的字符串本身就含有 % 或 _ 时， 要使用**ESCAPE** '<换码字符>' 短语对通配符进行转义。

    如：WHERE Cname LIKE 'DB**\\**_D' ESCAPE '\\'；

    ESCAPE '\\' 表示“\\”为换码字符

- 涉及空值的查询

  - IS NULL 或 IS NOT NULL
  - "IS"不能用"="代替

- 多重条件查询

  - AND和 OR来联结多个查询条件

#### ORDER BY子句

- SELECT [ALL|DISTINCT] <列名> [, <列名> ]...;

- 可以按一个或多个属性列排序
- 升序ASC，降序DESC，缺省值为升序
- ASC排序列为空值的元组最后显示，DESC反之

#### 聚集函数

- 计数
  - COUNT（[DISTINCT|ALL] *）
  - COUNT（[DISTINCT|ALL] <列名>）
- 求和
  - SUM（[DISTINCT|ALL] <列名>）
- 求平均值
  - AVG（[DISTINCT|ALL] <列名>）
- 求最大值
  - MAX（[DISTINCT|ALL] <列名>）
  - MIN（[DISTINCT|ALL] <列名>）

##### 注意点

- 聚集函数遇到空值时，除COUNT(*)外， 都跳过空值而只处理非空值。
- WHERE字句中是不能用聚集函数作 为条件表达式的。

#### GROUP BY子句

- 聚集函数的作用对象
  - 无分组：作用于整个查询结果
  - 有分组：分别作用于每个组
  - 按指定的一列或多列值分组，值相等的为一组
  - GROUP BY子句的作用对象是查询的中间结果表

#### HAVING子句

##### HAVING与WHERE的区别

| 方面     | WHERE                                                        | HAVING                                                     |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 实质     | 是约束声明                                                   | 是过滤声明                                                 |
| 作用时间 | 在查询数据库的结果返回之前对数据库中的查询条件进行约束，即在结果返回之前起作用 | 在查询数据库的结果返回之后进行过滤，即在结果返回之后起作用 |
| 作用对象 | WHERE子句作用于基表或视图，从中选择满足条件的元组            | HAVING短语作用于组，从中选择满足条件 的组。                |
| 聚合函数 | WHERE先于聚合函数执行，所以后面不能使用聚合函                | HAVING后面可以使用聚合函数                                 |

#### 连接查询

##### 注意点

- 连接条件中的各连接字段类型必须是可比的
- 排序合并法和索引连接(了解原理)

##### 几种连接方式

- 等值连接
  - [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 在WHERE子句中连接
- 自然连接
  - <表名1>.<列名1> = <表名2>.<列名2>
  - 在WHERE子句中连接
  - 等值连接的一种特殊情况，把目标列中重复的属性列去掉。
- 非等值连接
  - 在WHERE子句中连接
  - 连接运算符不为 = 的连接操作
- 自身连接
  - 在WHERE子句中连接
  - 一个表与其自己进行连接
  - 需要给表起别名以示区别且属性要使用前缀来区别
- 内连接
  - 内连接是系统默认的，可以省略INNER关键字。
  - 使用内连接后仍可使用WHERE子句指定条件。
  - 在FROM子句中连接。
  - <表名1>  [INNER] JOIN <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
- 外连接
  - 在FROM子句中连接
  - 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出
  - 左外连接：<表名1>  **LEFT [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 右外连接：<表名1>  **RIGHT [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
  - 完全外连接：<表名1>  **FULL [OUTER] JOIN** <表名2> ON [<表名1>.]<列名1> = [ <表名2>.]<列名2>
- 交叉连接
  - 在FROM子句中连接
  - 实际为笛卡尔积
  - <表名1>  **JOIN** <表名2> [ON ...]
  - ON语句的执行是在JOIN语句之前的，所以应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。

#### 嵌套查询

- 子查询不能使用ORDER BY子句

##### 嵌套查询求解方法

- 不相关子查询：子查询的查询条件不依赖于父查询
  - 从里到外的求解
- 相关子查询：子查询的查询条件依赖于父查询
  - 先从外层取第一个元组，带入到内层求解，WHERE子句返回结果为真加入结果集，然后取下一个元组以此循环。

##### 几种嵌套查询(搜索样例理解)

- 带有IN谓词的子查询
- 带有比较运算符的子查询
- 带有ANY（SOME）或ALL谓词的子查询
- 带有EXISTS谓词的子查询
  - 一些带EXISTS或NOT EXISTS谓词的子查询不能 被其他形式的子查询等价替换
  - 有带IN谓词、比较运算符、ANY和ALL谓词的 子查询都能用带EXISTS谓词的子查询等价替换
  - 由于带EXISTS量词的相关子查询只关心内层查询是否有返回值，并不需要查具体值，因此其效率并不一定低于其他形式的查询
  - 用EXISTS/NOT EXISTS实现全称量词(难点)
  - 用EXISTS/NOT EXISTS实现逻辑蕴函(难点)

#### 集合查询

##### 集合查询的种类

- 并操作UNION
  - <查询块> UNION <查询块>
  - WHERE <条件语句> OR <条件语句>
- 交操作INTERSECT
  - <查询块> INTERSECT <查询块>
  - WHERE <条件语句> AND <条件语句>
  - WHERE <列名> IN <查询块>
- 差操作EXCEPT
  - <查询块> EXCEPT <查询块>
  - WHERE <列名> NOT IN <查询块>

##### 对集合操作结果的排序

- ORDER BY子句只能用于对最终查询结果排序， 不能对中间结果排序，ORDER BY子句只能出现在最后。
- 对集合操作结果排序时，ORDER BY子句中只能用数字指定排序属性

### 索引|INDEX

#### 索引概述

- 索引由DBA或表的属主建立。
- DBMS会在PRIMARY KEY、UNIQUE上建立索引。
- 索引由DBMS自动维护、自动使用。
- RDBMS中索引一般采用B+树、HASH索引来实现，使用哪一个由RDBMS决定
  - B+树索引具有动态平衡的优点
  - HASH索引具有查找速度快的特点

#### 索引作用(了解)

- 快速找出匹配一个WHERE子句的行。
- 当执行联结时，从其他表检索行。
- 对特定的索引列找出MAX()或MIN()值。
- 如果排序或分组在一个可用键的最左面前缀上进行(例如，ORDER BY key_part_1,key_part_2)，排序或分组一个表。

- 如果所有键值部分跟随DESC，键以倒序被读取。 
- 在一些情况中，一个查询能被优化来检索值，不用咨询数据文件。

- 如果对某些表的所有使用的列是数字型的并且构成某些键的最左面前缀，为了更快，值可以从索引树被检索出来。 

#### 建立索引

- CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名> (<列名> [<次序>] [, <列名> [<次序>] ]…)
- UNIQUE表明此索引的每一个索引值只对应唯一的数据记录
- CLUSTER表示要建立的索引是聚簇索引，也即聚簇索引的索引项顺序与表中记录的物理顺序一致，MySQL里主键就是聚集索引。
- 聚簇索引的适用范围：
  - 很少对基表进行增删操作 
  - 很少对其中的变长列进行修改操作。

#### 删除索引

- DROP INDEX <索引名>

#### KEY与INDEX异同

| 方面                | KEY                               | INDEX                                                        |
| ------------------- | --------------------------------- | ------------------------------------------------------------ |
| 作用                | 约束和索引                        | 仅索引                                                       |
| 实现方式(在mysql下) | 既建立了constraint，又建立了index | 它创建时会在另外的表空间(mysql中的innodb表空间)以一个类似目录的结构存储 |

#### 一些KEY

| 命名        | 作用                                                     |
| ----------- | -------------------------------------------------------- |
| PRIMARY KEY | 约束一个存储主键和唯一性，同时也在此key上建立了一个index |
| UNIQUE KEY  | 约束数据的唯一性，同时也在这个key上建立了一个index       |
| FOREIGN KEY | 约束数据的引用完整性，同时也在这个key上建立了一个index   |

#### 总结

- INDEX的作用就仅仅是索引，而像UNIQUE INDEX中的INDEX，其实只是被当作KEY来看待。

### 数据插入|INSERT

- INSERT INTO <表名> [(<属性列1>[，<属性列2 >…)] VALUES (<常量1> [，<常量2>] …)
- RDBMS在执行插入语句时会检查所插元组是否破坏 表上已定义的完整性规则

#### 插入子查询

- INSERT INTO <表名> [(<属性列1> [，<属性列2>… )] 子查询；
- SELECT子句目标列的值的类型和值的个数与INTO子句匹配。

### 数据修改|UPDATE

- UPDATE <表名> SET <列名>=<表达式>[，<列名>=<表达式>]… [WHERE <条件>]；

### 删除数据|DELETE

- DELETE FROM <表名> [WHERE <条件>]；

### 视图|VIEW

- 虚表，是从一个或几个基本表（或视图）导出的表 
- 只存放视图的定义，不存放视图对应的数据 
- 基表中的数据发生变化，从视图中查询出的数据也随之改变

#### 创建视图

- CREATE VIEW <视图名> [(<列名> [，<列名>]…)]
  AS <子查询> [WITH CHECK OPTION]；
- 子查询不允许含有ORDER BY子句和DISTINCT 短语
- 在对视图进行删改的操作回自动加入子查询语句。
- 对视图进行插入操作，会对插入的值进行判断
  - 如果不符合子查询语句，则拒绝插入
  - 如果没有提供子查询语句的值，则默认为子查询语句的值。

##### 带表达式的视图

- 派生属性称为虚拟列。带虚拟列的视图称为 带表达式的视图。
- 带表达式的视图必须明确定义组成视图的各个属性列名

##### 分组视图

- 用带集函数和GROUP BY子句的查询来定义的视图称为分组视图
- 分组视图必须明确定义组成视图的各个属性列名

#### 删除视图

- DROP VIEW <视图名> [CASCADE(级联删除)]；

#### 视图的可更新性

- 若视图是由两个以上基本表导出的，则此 视图不允许更新。
- 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
- 若视图的字段来自集函数，则此视图不允许更新。
- 若视图定义中含有GROUP BY子句，则此视图不允许更新。
- 若视图定义中含有DISTINCT短语，则此视图不允许更新。
- 若视图定义中有嵌套查询，并且内层查询的FROM子 句中涉及的表也是导出该视图的基本表，则此视图不允许更新。

### 其他关键字

#### 自增长|AUTO_INCREMENT

##### 用法示例

```sql
CREATE TABLE Persons
(
	id int NOT NULL AUTO_INCREMENT,
	PRIMARY KEY (P_Id)
)
```

##### 注意点

- 自增长字段的值从1开始, 每次递增1。
- 自增长字段数据不可以重复, 合适生成唯一的id。
- 自增长字段可以使用null或者default来设置值。
- 自增长字段必须是主键 (primary key)。

### 数据类型

| 数据类型         | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| CHAR(n)          | 长度为n的定长字符串                                          |
| VARCHAR(n)       | 最大长度为n的变长字符串                                      |
| INT              | 长整数（也可以写作INTEGER）                                  |
| SMALLINT         | 短整数                                                       |
| NUMERIC(p,d)     | 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 |
| REAL             | 取决于机器精度的浮点数                                       |
| Double Precision | 取决于机器精度的双精度浮点数                                 |
| FLOAT(n)         | 浮点数，精度至少为n位数字                                    |
| DATE             | 日期，包含年、月、日，格式为YYYY-MM-DD                       |
| TIME             | 时间，包含一日的时、分、秒，格式为HH:MM:SS                   |

## 数据库安全性

- DBA拥有所有对象权限
- 用户拥有自己建立的对象的全部操作权限

### 权限授权|GRANT

- GRANT <权限>[,<权限>]...

  ​						[ON <对象类型> <对象名>]
  ​						TO <用户>[,<用户>]...
  ​						[WITH GRANT OPTION];

- 加上WITH GRANT OPTION可以让权限可传递

- GRANT后可以加

  - ALL PRIVILEGES 全部权限
  - SELECT/INSERT/UPDATE/... 对应权限
  - INSERT(<列名>)/UPDATE(<列名>) 修改指定列的权限

- ON后可以加

  - TABLE <表名> 表的对应权限

- TO后可以加

  - PUBLIC 全体成员对应权限
  - <用户名> 指定用户对应权限

### 权限回收|REVOKE

- REVOKE <权限>[,<权限>]...

  ​						[ON <对象类型> <对象名>]

  ​						FROM <用户>[,<用户>]... [CASCADE];

- 加上CASCADE可以级联回收权限

- 其他与GRANT基本相同

### 权限表(了解)

![img](https://gitee.com/lin_haoran/Picgo/raw/master/img/200303-20190623142132456-188693664.jpg)

### 创建数据库模式的权限

- CREATE USER \<用户名>
  [WITH] [DBA | RESOURCE | CONNECT]

| 拥有的权限\可否进行的操作 | CREATE USER | CREATE SCHEMA | CREATE TABLE | 登录\执行数据查询和操纵 |
| ------------------------- | ----------- | ------------- | ------------ | ----------------------- |
| DBA                       | Y           | Y             | Y            | Y                       |
| RESOURCE                  | N           | N             | Y            | Y                       |
| CONNECT                   | N           | N             | N            | 拥有相应权限时可以      |

### 数据库角色

- 数据库角色: 被命名的一组与数据库操作相关的权限
  - 角色是权限的集合
  - 可以为一组具有相同权限的用户创建一个角色
  - 简化授权的过程

#### 创建角色

- 创建角色

  - CREATE ROLE <角色名>

- 给角色授权

  - GRANT <权限> [,<权限>]…

  ​						ON <对象类型>对象名

  ​						TO <角色> [,<角色>] ...

- 角色授权

  - GRANT <角色1> [，<角色2>]…

    ​						TO <角色3> [,<用户1>]

    ​						[WITH ADMIN OPTION]

- 角色回收

  - REVOKE <权限> [,<权限>]…

    ​						ON <对象类型> <对象名>

    ​						FROM <角色> [,<角色>]...

## 数据库完整性

- 数据的**正确性**和**相容性**

### 实体完整性

- 在创建表时使用PRIMARY KEY定义主码

- 对于单属性的码有两种声明方式

  - 定义为列级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT PRIMARY KEY,NAME CHAR(20));
    ```

  - 定义为表级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT,NAME CHAR(20),PRIMARY KEY(ID));
    ```

- 对于多属性的码有一种声明方式

  - 定义为表级约束条件,例如

    ```sql
    CREATE TABLE EP(ID INT,NAME CHAR(20),PRIMARY KEY(ID,NAME));
    ```

### 参照完整性

- 在创建表时使用FOREIGN KEY定义外码

- 用REFERENCES指明这些外码参照的主码

  ```sql
    CREATE TABLE EP1(NO1 INT,FOREIGN KEY(NO1) REFERENCES EP(ID) [ON DELETE CASCADE ON UPDATE CASCADE]);
    //设置了级联更新删除
  ```

#### 违约处理

| 被参照表           | 参照表             | 违约处理                 |
| ------------------ | ------------------ | ------------------------ |
| 可能破坏参照完整性 | 插入元组           | 拒绝                     |
| 可能破坏参照完整性 | 修改外码值         | 拒绝                     |
| 删除元组           | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值         | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |

### 用户自定义完整性

#### 属性上的约束条件

- 在创建表时定义`NOT NULL\UNIQUE\CHECK`

  - CHECK可以在括号内加布尔条件,例如

    ```sql
    CREATE TABLE EP
    	(SEX CHAR(2) CHECK(SEX IN ('男','女'))
    	)
    ```

- 违约拒绝执行

#### 元组上的约束条件

- 在创建表时用CHECK定义元组上的约束条件

  ```sql
    CREATE TABLE EP
    	(ID INT,
         SEX CHAR(2),
         CHECK(SEX IN ('男','女') AND ID >=0)
    	)
  ```

- 违约拒绝执行

### 约束|CONSTRAINT

- 约束的主要作用是给与名字便于修改和删除

#### 创建约束

- CONSTRAINT <完整性约束条件名>
  [PRIMARY KEY短语
  |FOREIGN KEY短语
  |CHECK短语]

  ```sql
  CREATE TABLE EP
  	(ID INT CONSTRAINT C1 CHECK(ID >= 0),
       SEX CHAR(2) CONSTRAINT C2 NOT NULL,
       CONSTRAINT SKEY PRIMARY KEY(ID)
  	)
  ```

#### 修改表中的完整性限制

- 用 `ALTER TABLE`修改表中的完整性限制

  ```sql
  ALTER TABLE DROP CONSTRAINT <约束名>;
  ALTER TABLE ADD CONSTRAINT <约束名> <约束条件>;
  ```

### 触发器

- 触发器由**事件驱动**

#### 定义触发器

- CREATE TRIGGER <触发器名>
  {BEFORE | AFTER} <触发事件> ON <表名>
   	FOR EACH {ROW | STATEMENT}
   	[WHEN <触发条件>]
   	<触发动作体>

  | 定义触发器 | 说明                                                         |
  | :--------- | ------------------------------------------------------------ |
  | 创建者     | 表的拥有者                                                   |
  | 表名       | 触发器的目标表                                               |
  | 触发事件   | INSERT\DELETE\UPDATE                                         |
  | 触发器类型 | - 行级触发器,对每个命令仅触发一次 <br />- 语句级触发器,对表进行一次操作就触发一次 |
  | 触发条件   | 布尔值为真触发                                               |
  | 触发动作体 | - 可以是一个匿名SQL过程块<br />- 也可以是已创建的存储过程的调用 |

#### 激活触发器

- 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行
- 一个数据表上可能定义了多个触发器,遵循如下的执行顺序
  - 执行该表上的BEFORE触发器
  - 激活触发器的SQL语句
  - 执行该表上的AFTER触发器

#### 删除触发器

- DROP TRIGGER <触发器名> ON <表名>

## 关系数据理论

- 平凡函数依赖：$X\to Y$，并且$Y\subseteq X$
  - 例如$(Sno,Cno)\to Grade$
- 非平凡函数依赖：$X\to Y$，并且$Y\not \subseteq X$
  - 例如$(Sno,Cno)\to Cno$
- 完全函数依赖：$X\to Y$，并且$X$的任意一个真子集$X'$都有$X'\not \to Y$，则称Y对X完全函数依赖，记作$X\stackrel{F}{\to}Y$。
- 部分函数依赖：$X\to Y$，但是Y不完全函数依赖于X，则称Y对X部分函数依赖，记作$X\stackrel{P}{\to}Y$。
- 传递函数依赖：$X\to Y,(Y\not \subseteq X),Y\not \to X,Y\to Z,Z\not \subseteq Y$，则称Z对X传递函数依赖。

### 范式|NF

- $1NF\supset 2NF \supset 3NF \supset BCNF \supset 4NF\supset 5NF$

- 第一范式|1NF
  - 如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于第一范式。

- 第二范式|2NF
  - 在1NF基础上，消除了非主属性对码的部分函数依赖

- 第三范式|3NF
  - 在2NF基础上，消除了非主属性对码的传递函数依赖

- BC范式|BCNF
  - 在3NF基础上，消除了主属性对码的部分和传递函数依赖

- 第四范式|4NF
  - 在BCNF基础上，消除了非平凡且非函数依赖的多值依赖

## 数据库设计

### E-R图

- 要掌握到题目给出实体、关系，然后依照题目画出er图，同时还要规范化关系模式。
- 结合第七章2ppt

#### 原则

- 属性不能再具有需要描述的性质。即属性必须是不可分的数据项

- 属性不能与其他实体具有联系。联系只能发生在实体之间

  ![image-20200701221227349](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200701221218127.png)

#### E-R图向关系模型转换

- 将E-R图转换为关系模型：将实体、实体的属性和实体之间的联系转换为关系模式。
- 1：1联系
  - 转换为一个独立的关系模式
  - 与某一端实体类对应的关系模式合并
- 1：n联系
  - 转换为一个独立的关系模式
  - 与n端对应的关系模式合并
- m：n联系
  - 转换为一个独立的关系模式
  - 例如`选修`是一个n：m关系模式，可以转换为学号与课程号为关系的组合码：选修(<span style="border-bottom:1px solid;">学号</span>，<span style="border-bottom:1px solid;">课程号</span>，成绩)
- 三个及以上的实体的多元联系
  - 转换为一个关系模式
- 有相同码的关系模式
  - 直接合并

#### 数据模型优化

- 用规范化理论为指导进行优化。

### 数据库的物理设计

#### DBMS常用存取方法

- 索引方法
  - B+树索引方法
  - 经典存取方法
- 聚簇方法
- HASH方法

#### 索引

- 选择索引存取的规则
  - 如果一个(或一组)属性经常在查询条件中出现,则考虑在这个(或这组)属性上建立索引(或组合索引)
  - 如果一个属性经常作为最大值和最小值等聚集函数的参数,则考虑在这个属性上建立索引
  - 如果一个(或一组)属性经常在连接操作的连接条件中出现,则考虑在这个(或这组)属性上建立索引

#### 聚簇

- 为了提高某个属性(或属性组)的查询速度,把这个或这止属性(称为聚簇码)上具有相同值的元组集中存放在连续物理块称为聚簇
- 聚簇的优点
  - 提高查询效率
  - 节省存储空间
- 聚簇的缺点
  - 只能提提高某些特定应用的性能
- 聚簇的适用范围
  - 可以用于单个关系的独立聚簇，也可以用于多关系的组合聚簇
  - 当通过聚簇码进行访问或连接是该关系的主要应用,与聚簇码无关的其他访问很少或者是次要的时,可以使用聚簇。
  - 尤其当SQL语句中包含有与聚簇码有关的 ORDER BY,GROUP BY,UNON, DISTINCT等子句或短语时,使用聚簇特别有利,可以省去对结果集的排序操作
- 优化聚簇
  - 从聚簇中删除经常进行全表扫描的关系;
  - 从聚簇中删除更新操作远多于连接操作的关系;
  - 不同的聚簇中可能包含相同的关系，关系可以在某个聚簇中,但不能同时加入多个聚簇
    - 从这多个聚簇方案(包括不建立聚簇)中选择一个较优的,即在这个聚簇上运行各种事务的总代价最小

#### HASH

- 当一个关系满足下列两个条件时,可以选择HASH存取
  方法
  - 该关系的属性主要出现在等值连接条件中或主要出现在相等比较选择条件中该关系的大小可预知,而且不变;
  - 该关系的大小动态改变,但所选用的DBMS提供了动态HASH存取方法

## 关系查询处理和查询优化

### 连接操作实现方法

- nested loop

- sort-merge join
- index join

- hash join

### 查询操作优化

- 关系代数表达式等价变换规则
- 查询树的启发式优化

## 数据库恢复技术

### 事务

#### 定义

- 一个数据库操作序列
- 一个不可分割的工作单位
- 恢复和并发控制的基本单位

#### 事务和程序区别

- 在关系型数据库中,一个事务可以是一条或多条SQL语句,也可以包含一个或多个程序
- 一个程序通常包含多个事务

#### 定义事务的范式

- 显式定义

  - ```sql
    BEGIN TRANSACTION
    	SQL 语句
    	SQL 语句
    	...
    COMMIT
    
    BEGIN TRANSACTION 
    	SQL 语句
    	SQL 语句
    	...
    ROLLBACK
    ```

- 隐式定义

  - DBMS按缺省规定自动划分事务

事务特性|ACID

- 原子性
- 一致性
- 隔离性
- 持续性

### 恢复的实现技术

#### 静态转储

- 在系统中无运行事务时进行的转储操作
- 转储开始时数据库处于一致性状态
- 转储期间不允许对数据库的任何存取、修改活动
- 得到的一定是一个数据一致性的副本
  - 优点:实现简单
  - 缺点:降低了数据库的可用性
- 转储必须等待正运行的用户事务结束
- 新的事务必须等转储结束

#### 动态转储

- 转储操作与用户事务并发进行
- 转储期间允许对数据库进行存取或修改
- 优点
  - 不用等待正在运行的用户事务结東
  - 不会影响新事务的运行
- 动态转储的缺点
  - 不能保证副本中的数据正确有效
- 利用动态转储得到的副本进行故障恢复
  - 需要把动态转储期间各事务对数据库的修改活动登记下来,建立日志文件
  - 后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态

#### 海量转储

- 每次转储全部数据库
- 从恢复角度看,使用海量转储得到的后备副本进行恢复往往更方便

#### 增量转储

- 只转储上次转储后更新过的数据
- 如果数据库很大,事务处理又十分频繁,增量转储方式更实用更有效

#### 以记录为单位的日志

- 内容
  - 各个事务的开始标记
  - 各个事务的结束标记
  - 各个事务的所有更新操作
  - 事务标示，标明是哪个事务
  - 操作类型，插入、删除或秀给
  - 操作对象
  - 更新前数据旧值
  - 更新后数据新值
- 静态转储副本和日志文件进行恢复
  - ![image-20200704144057842](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704144057842.png)
  - 必须先写日志文件，后写数据库

### 事务故障的恢复

- 定义：事务在运行至正常终止点前被终止
- 恢复方法
  - 由恢复子系统应利用日志文件撤消(UNDO)此事务已对数据库进行的修改
- 事务故障的恢复由系统自动完成,对用户是透明的,不需要用户干预
- 恢复步骤
  - 反向扫描文件日志(即从最后向前扫描日志文件)查找该事务的更新操作。
  - 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。
    - 插入操作,“更新前的值”为空,则相当于做删除操作
    - 删除操作,“更新后的值”为空,则相当于做插入操作
    - 若是修改操作,则相当于用修改前值代替修改后值
  - 继续反向扫描日志文件,查找该事务的其他更新操作,并做同样处理
  - 如此处理下去,直至读到此事务的开始标记,事务故障恢复就完成了

### 系统故障的恢复

- 系统故障造成数据库不一致状态的原因
  - 未完成事务对数据库的更新已写入数据库
  - 已提交事务对数据库的更新还留在缓冲区没来得及写入数据库
- 恢复方法
  - Undo故障发生时未完成的事务
  - Redo已完成的事务
- 系统故障的恢复由系统在重新启动时自动完成,不需要用户干预

### 介质故障的恢复

- 重装数据库
- 重做已完成的事务

### 具有检查点的数据恢复

- 在日志文件中增加检查点记录
- 增加重新开始文件
- 恢复子系统在登录日志文件期间动态地维护日志

![image-20200704153118097](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704153118097.png)

![image-20200704153305646](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200704153305646.png)

## 并发控制

- 并发控制机制的任务
  - 对并发操作进行正确调度
  - 保证事务的隔离性
  - 保证数据库的一致性

- 并发操作带来的数据不一致性
  - 丢失修改( Lost Update)
  - 不可重复读( Non-repeatable Read)
  - 读“脏”数据( Dirty Read)

### 封锁

- 并发控制的主要技术
  - 有封锁( Locking)
    - 排他锁（写锁）
    - 共享锁（读锁）
  - 时间戳( Timestamp)
  - 乐观控制法
- 活锁和死锁
  - 活锁是指事务插队导致有的事务永远无法获取资源
  - 死锁是指相互等待对方释放资源，形成死锁

### 并发调度的可串行性

- 可串行化( Serializable)调度
  - 多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行这些事务时的结果相同
- 可串行性( Serializability)
  - 是并发事务正确调度的准则
  - 一个给定的并发调度,当且仅当它是可串行化的才认为是正确调度
- 可串行化调度的充分条件
  - 一个调度Sc在保证冲突操作的次序不变的情况下,通过交换两个事务不冲突操作的次序得到另一个调度Sc,如果Sc是串行的,称调度Sc为冲突可串行化的调度
  - 一个调度是冲突可串行化,一定是可串行化的调度

### 两段锁协议

​	指所有事务必须分两个阶段对数据项加锁和解锁

- 在对任何数据进行读、写操作之前,事务首先要获得对该数据的封锁
- 在释放一个封锁之后,事务不再申请和获得任何其他封锁
- 两端的含义
  - 第一阶段是获得封锁,也称为扩展阶段。事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁
  - 第二阶段是释放封锁,也称为收缩阶段。事务可以释放任何数据项上的任何类型的锁,但是不能再申请任何锁

