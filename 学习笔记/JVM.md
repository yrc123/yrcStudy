## JVM

### 概述

**Java虚拟机**

![image-20200607205751748](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607205751748.png)

### Java内存区域与内存溢出异常

#### 运行时数据区域

![image-20200608000044625](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607224519737.png)

​	其中方法区、堆、执行引擎和本地库接口是由所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区。

#### 程序计数器

- 线程私有。随线程而生，随线程而灭。

- 用来记录当前线程字节码的行号，字节码解释器通过改变他来选取下一条需要执行的字节码指令。
- 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以每条线程都有一个单独的程序计数器。
- 如果执行的是Java方法，它记录的是正在执行的虚拟机字节码指令的地址。
- 如果执行的是本地(Native)方法，它为空(Undefined)。

#### Java虚拟机栈

- 线程私有。随线程而生，随线程而灭。
- 当每个方法执行时，Java虚拟机都会为它创建一个**栈帧**(Stack Frame)用来存储方法的信息，当方法执行完毕后出栈。
- 存储了包括存储局部变量表、操作数栈、动态连接、方法出口等信息。
- 局部变量表存储了编译器可知的**Java基本类型**。以局部**变量槽(**Slot)为单位。64位长的类型会占用2个变量槽。
- 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
- 一个变量槽实际的占用空间的大小由虚拟机实现。

####  本地方法栈

- 线程私有。随线程而生，随线程而灭。
- 同虚拟机栈类似，区别是保存的不是字节码而是本地方法。

####  Java堆

- 被所有线程共享。
- 在虚拟机启动时创建。
- 唯一目的是存放对象实例。
- 被垃圾收集器管理。
- 可被实现为固定大小，也可为可拓展大小，主流为可拓展大小。

#### 方法区

- 被所有线程共享。
- 用于存储被虚拟机加载的类型信息、常量、静态变量等数据。
- 用堆实现。
- 该区域内存回收主要是针对常量池的回收和类型的卸载。

#### 运行时常量池

- 为方法区的一部分。
- 常量池表用来存储编译期生成的字面量和符号引用，在类加载后存放到常量池中。
- 具有动态性，可以在常量可以在非编译期产生。

#### 对象的创建

1. **Java虚拟机遇到new指令**。
2. **检查类是否存在**。检查指令的参数是否在常量池内定位到一个类的符号引用，检查这个符号引用的类是否被加载、解析、初始化过。若没有则执行类的加载过程。
3. **虚拟机为新生对象分配内存**。分配内存的方法有两种：**指针碰撞**和**空闲列表**，使用那种方法主要看Java堆**是否规整**并且垃圾收集器是否有**空间压缩整理**的能力。同时还要考虑线程安全。
4. 对象进行初始化为零值。
5. 对对象进行设置。如对象是哪个类的实例、对象的GC分带年龄信息等将被存放到对象头中。
6. 执行构造函数。

#### 对象的内存布局

- 分为3部分：对象头、实例数据、对齐填充。
- 对象头包含两类信息：第一类是存储对象自身运行时数据，第二类是类型指针
  - 运行时数据包含如GC分布带、锁状态标志位、线程持有的锁等信息，这些信息被存储在32位或64位的Mark Word中。
  - Java虚拟机通过类型指针来确定对象是哪个类的实例。
- 实例数据是对象存储的有效信息，即文默在代码中定义的各种类型字段。
- 对齐填充是为了满足Java虚拟机要求的对象起始位置必须是8字节的整数倍。

#### 对象的访问定位

- 主流的访问粉丝有使用句柄访问和直接指针两种
- 使用句柄访问，好处是当对象被移动，只会改变句柄中的实例数据指针，而reference不需要修改。

![image-20200608113045602](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113045602.png)



- 使用直接指针访问，好处是节省一次指针定位的时间。

![image-20200608113135243](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113135243.png)

#### 内存溢出实例

- Java堆溢出：

  > Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

- 虚拟机栈和本地方法栈溢出：

  >1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
  >2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

- 方法区和运行时常量池溢出：

  > 运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”。

- 本机直接内存溢出：

  >由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。

### 垃圾收集器与内存分配策略

#### 引用计数器算法

​	该方法的原理是在对象中添加一个引用计数器，当被引用时计数器加一，当引用失效时计数器减一，当计数器为零时，说明对象不可再被引用。

​	该方法的优点是原理简单，判定高效，但是当对象相互引用，形成一个环时，就无法正确的释放空间。

​	主流的Java虚拟机不使用这个方法。

#### 可达性分析算法

​	通过"GC Roots"的根对象为起始节点集，开始向下搜索，走过的路程称为"引用链"。

![image-20200608204207423](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608204207423.png)

​	可被作为GC Roots的对象包括：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 在方法区中类静态属性引用的对象。
- 在方法区中常量引用的对象。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
- 不可达对象要经历两次标记才会被宣告死亡。
  1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。
  2. 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。
  3. 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。


#### 引用

##### 强引用|Strongly Reference

- 是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。
- 被强引用所引用的对象永远不会被垃圾收集器回收。
- Vector类的clear方法是通过把引用赋值为null来实现清理工作。

##### 软引用|Soft Reference

- 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它。
- 在系统将要发生内存溢出异常前，会把被软引用的对象列进回收范围之中进行第二次回收。
- 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。

##### 弱引用|Weak Reference

- 弱引用也是用来描述非必需对象的。
- 当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

##### 虚引用|Phantom Reference

- 虚引用并不影响对象的生命周期。
- 虚引用只是为了能在这个对象被收集器回收时收到一个系统通知。
- 无法通过虚引用来取得一个对象实例 。

#### 回收方法区

- 方法区的垃圾收集主要分为两部分：废弃的常量和不再使用的类型。

- 判定一个常量是否废弃：

  1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

  2. 加载该类的类加载器已经被回收。

  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方
     法。

- 常量池中其他类(接口)、方法、字段的符号引用也与此类似。

#### 垃圾收集算法

##### 标记清除算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，统一回收掉所有被标记的对象。

- 缺点
  - 执行效率不稳定。
  - 内存空间碎片化。

##### 标记复制算法

- 内存被分成大小相等的两块，每次只使用一块。
- 当一块用完，就将存活的对象复制到另一块内存上，然后把已使用的内存空间一次清理掉。
- 实现简单，运行高效。
- 缺点
  - 如果大部分对象存活，复制对象的消耗过大。
  - 可使用的内存缩小一半。

##### 标记整理算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，让存活的对象向内存一端移动。

3. 直接清理掉边界以外的内存。

- 缺点
  - 如果回收时有大量对象存活，移动存活对象开销大。
  - 移动对象的操作要求全程暂停用户应用。

##### 分带收集算法

- 根据内存中对象的存活周期不同，在JVM中一般把内存划分为**新生代**和**老年代**。
- 老年代的特点是每次垃圾收集时只有少量对象需要被回收。
- 新生代的特点是每次垃圾回收时都有大量的对象需要被回收。

- 在新生代一般使用标记复制算法，并且不是按1:1的比例来划分内存。
- 在年老代一般使用的是标记整理算法。

- 创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中。
- 当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。
- **永久代**用来存放class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

#### HotSpot的算法细节实现

#### 经典垃圾收集器

##### Seria收集器

![image-20201117114457175](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201117114457175.png)

- 使用一个线程去完成垃圾收集
- 优点
  - 简单高效
  - 适合运行在客户端下的虚拟机
  - 内存占用小
- 缺点
  - 要暂停用户线程

##### ParNew收集器

![image-20201117114508651](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201117114508651.png)

- ParNew收集器除了支持多线程**并行**收集之外，其他与Serial收集器相比并没有太多创新之处
- 并行与并发
  - **并行**描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于**等待状态**
  - **并发**描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程**都在运行**

##### Parallel Scavenge收集器

- 基于标记-复制算法
- 目标是达到一个可控制的**吞吐量**

$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾搜集时间}
$$

##### Serial Old收集器

![image-20201120084853671](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120084853671.png)

- Serial的老年代版本

- 使用标记整理算法

##### Parallel Old收集器

![image-20201120090101325](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120090101325.png)

- Parallel Old是Parallel Scavenge收集器的老年代版本
- 支持多线程并发收集
- 基于标记-整理算法实

##### CMS收集器

![image-20201120090230703](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120090230703.png)

- 概念
  - Minor GC（新生代）
  - Major GC（老年代）
  - Full GC（整个Java堆）
  - CMS只能执行其中一种GC
- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- 基于标记-清除算法
- 收集分为四个部分
  - 初始标记(要暂停用户线程)
  - 并发标记
  - 重新标记(要暂停用户线程)
  - 并发清除
- 四个部分的作用
  - 初始标记用来标记GC Roots能直接关联到的对象
  - 并发标记是从GC Roots直接关联对象遍历整个对象图
  - 重新标记是为了修正并发期间的数据不一致
  - 并发清除是清除掉标记阶段被判断成死亡的对象
- 缺点
  - 无法处理"浮动垃圾"，即在并发标记和并发清理生成的垃圾
  - 因为在并发的时候用户线程还在运行，所以CMS不能等到老年代几乎满了才进行搜集。
  - 要预留空间，不然会出现"并发失败"，要暂停用户线程，并临时使用Serial Old来收集
  - 因为是标记清除算法，会产生很多碎片，触发一次Full GC

##### Garbage First(G1) 收集器

![image-20210406114807671](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210406114807671.png)

- 可以执行Mixed GC（不用决定是面向新生代，老年代还是Java堆）
- 将内存空间分为很多相等大小的区域（Region），每个Region既可以是新生代也可以是老年代。