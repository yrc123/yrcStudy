## JVM

### 概述

**Java虚拟机**

![image-20200607205751748](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607205751748.png)

### Java内存区域与内存溢出异常

#### 运行时数据区域

![image-20200608000044625](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200607224519737.png)

​	其中方法区、堆、执行引擎和本地库接口是由所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区。

#### 程序计数器

- 线程私有。随线程而生，随线程而灭。

- 用来记录当前线程字节码的行号，字节码解释器通过改变他来选取下一条需要执行的字节码指令。
- 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以每条线程都有一个单独的程序计数器。
- 如果执行的是Java方法，它记录的是正在执行的虚拟机字节码指令的地址。
- 如果执行的是本地(Native)方法，它为空(Undefined)。

#### Java虚拟机栈

- 线程私有。随线程而生，随线程而灭。
- 当每个方法执行时，Java虚拟机都会为它创建一个**栈帧**(Stack Frame)用来存储方法的信息，当方法执行完毕后出栈。
- 存储了包括存储局部变量表、操作数栈、动态连接、方法出口等信息。
- 局部变量表存储了编译器可知的**Java基本类型**。以局部**变量槽(**Slot)为单位。64位长的类型会占用2个变量槽。
- 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
- 一个变量槽实际的占用空间的大小由虚拟机实现。

####  本地方法栈

- 线程私有。随线程而生，随线程而灭。
- 同虚拟机栈类似，区别是保存的不是字节码而是本地方法。

####  Java堆

- 被所有线程共享。
- 在虚拟机启动时创建。
- 唯一目的是存放对象实例。
- 被垃圾收集器管理。
- 可被实现为固定大小，也可为可拓展大小，主流为可拓展大小。

#### 方法区

- 被所有线程共享。
- 用于存储被虚拟机加载的类型信息、常量、静态变量等数据。
- 用堆实现。
- 该区域内存回收主要是针对常量池的回收和类型的卸载。

#### 运行时常量池

- 为方法区的一部分。
- 常量池表用来存储编译期生成的字面量和符号引用，在类加载后存放到常量池中。
- 具有动态性，可以在常量可以在非编译期产生。

#### 对象的创建

1. **Java虚拟机遇到new指令**。
2. **检查类是否存在**。检查指令的参数是否在常量池内定位到一个类的符号引用，检查这个符号引用的类是否被加载、解析、初始化过。若没有则执行类的加载过程。
3. **虚拟机为新生对象分配内存**。分配内存的方法有两种：**指针碰撞**和**空闲列表**，使用那种方法主要看Java堆**是否规整**并且垃圾收集器是否有**空间压缩整理**的能力。同时还要考虑线程安全。
4. 对象进行初始化为零值。
5. 对对象进行设置。如对象是哪个类的实例、对象的GC分带年龄信息等将被存放到对象头中。
6. 执行构造函数。

#### 对象的内存布局

- 分为3部分：对象头、实例数据、对齐填充。
- 对象头包含两类信息：第一类是存储对象自身运行时数据，第二类是类型指针
  - 运行时数据包含如GC分布带、锁状态标志位、线程持有的锁等信息，这些信息被存储在32位或64位的Mark Word中。
  - Java虚拟机通过类型指针来确定对象是哪个类的实例。
- 实例数据是对象存储的有效信息，即文默在代码中定义的各种类型字段。
- 对齐填充是为了满足Java虚拟机要求的对象起始位置必须是8字节的整数倍。

#### 对象的访问定位

- 主流的访问粉丝有使用句柄访问和直接指针两种
- 使用句柄访问，好处是当对象被移动，只会改变句柄中的实例数据指针，而reference不需要修改。

![image-20200608113045602](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113045602.png)



- 使用直接指针访问，好处是节省一次指针定位的时间。

![image-20200608113135243](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608113135243.png)

#### 内存溢出实例

- Java堆溢出：

  > Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

- 虚拟机栈和本地方法栈溢出：

  >1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
  >2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

- 方法区和运行时常量池溢出：

  > 运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”。

- 本机直接内存溢出：

  >由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。

### 垃圾收集器与内存分配策略

#### 引用计数器算法

​	该方法的原理是在对象中添加一个引用计数器，当被引用时计数器加一，当引用失效时计数器减一，当计数器为零时，说明对象不可再被引用。

​	该方法的优点是原理简单，判定高效，但是当对象相互引用，形成一个环时，就无法正确的释放空间。

​	主流的Java虚拟机不使用这个方法。

#### 可达性分析算法

​	通过"GC Roots"的根对象为起始节点集，开始向下搜索，走过的路程称为"引用链"。

![image-20200608204207423](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20200608204207423.png)

​	可被作为GC Roots的对象包括：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 在方法区中类静态属性引用的对象。
- 在方法区中常量引用的对象。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
- 不可达对象要经历两次标记才会被宣告死亡。
  1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。
  2. 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。
  3. 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。


#### 引用

##### 强引用|Strongly Reference

- 是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。
- 被强引用所引用的对象永远不会被垃圾收集器回收。
- Vector类的clear方法是通过把引用赋值为null来实现清理工作。

##### 软引用|Soft Reference

- 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它。
- 在系统将要发生内存溢出异常前，会把被软引用的对象列进回收范围之中进行第二次回收。
- 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。

##### 弱引用|Weak Reference

- 弱引用也是用来描述非必需对象的。
- 当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

##### 虚引用|Phantom Reference

- 虚引用并不影响对象的生命周期。
- 虚引用只是为了能在这个对象被收集器回收时收到一个系统通知。
- 无法通过虚引用来取得一个对象实例 。

#### 回收方法区

- 方法区的垃圾收集主要分为两部分：废弃的常量和不再使用的类型。

- 判定一个常量是否废弃：

  1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

  2. 加载该类的类加载器已经被回收。

  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方
     法。

- 常量池中其他类(接口)、方法、字段的符号引用也与此类似。

#### 垃圾收集算法

##### 标记清除算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，统一回收掉所有被标记的对象。

- 缺点
  - 执行效率不稳定。
  - 内存空间碎片化。

##### 标记复制算法

- 内存被分成大小相等的两块，每次只使用一块。
- 当一块用完，就将存活的对象复制到另一块内存上，然后把已使用的内存空间一次清理掉。
- 实现简单，运行高效。
- 缺点
  - 如果大部分对象存活，复制对象的消耗过大。
  - 可使用的内存缩小一半。

##### 标记整理算法

1. 首先标记出所有需要回收的对象。

2. 在标记完成后，让存活的对象向内存一端移动。

3. 直接清理掉边界以外的内存。

- 缺点
  - 如果回收时有大量对象存活，移动存活对象开销大。
  - 移动对象的操作要求全程暂停用户应用。

##### 分带收集算法

- 根据内存中对象的存活周期不同，在JVM中一般把内存划分为**新生代**和**老年代**。
- 老年代的特点是每次垃圾收集时只有少量对象需要被回收。
- 新生代的特点是每次垃圾回收时都有大量的对象需要被回收。

- 在新生代一般使用标记复制算法，并且不是按1:1的比例来划分内存。
- 在年老代一般使用的是标记整理算法。

- 创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中。
- 当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。
- **永久代**用来存放class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

#### HotSpot的算法细节实现

##### 根节点枚举

​	查找引用链可以并发，而枚举根节点时要**暂停**用户线程

**准确式GC**

​	保守式GC和准确式GC的区别就是，GC时是否知道内存上的某个位置数据到底是引用类型还是别的什么类型

​	在扫描栈上的内存时，保守式GC因为不知道那些内存是引用，哪些是别的类型，所以要遍历扫描，而且还要要猜测（是否是能被4整除等等）来判断当前数据是否是指针，这样不但效率不高，而且可以会导致已经死亡的对象不能被释放。

​	而准确式的GC就是通过了一个**外部表OopMap**来记录内存中对应数据对应的类型

​	值得一提的是，HotSpot是**为了实现准确式的GC**才使用了OopMap，顺便加快了GC速度

**OopMap**

​	一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，也会在特定的位置记录下栈里和寄存器里哪些位置是引用

​	有了OopMap，在枚举根节点的时候只要枚举引用类型即可

##### 安全点

​	因为很多操作都会导致OopMap被修改，如果每次碰到就生成新的OopMap，代价很大。

​	所以引入了安全点，只有在安全点处对OopMap进行统一更新，意味着只有在安全点除OopMap才是准确的

​	为了保证在垃圾收集的时候所有线程都到达安全点，可以使用抢先式中断或主动式中断。

- **抢先式中断**是系统在垃圾收集时主动中断所有用户线程，之后再恢复未到安全点的线程。这个方法几乎没有被使用
- **主动式中断**是设置一个标记位，所有线程轮询这个标志，发现为真时到最近的一个安全点主动挂起

##### 安全区域

​	遇到这样一个问题，如果当前线程没有到达安全点，但是同时又长时间没有被分配cpu时间，导致其无法自己运行到安全点挂起。所以要引入安全区域（Safe Region）。

​	安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

​	在用户线程进入安全区时，会标识自己进入安全区。在出安全区时，会判断现在是否完成了根节点枚举，如果没有就等到收到离开安全区信号才能离开安全区

##### 记忆集与卡表

​	因为对象可能会**跨代引用**：老年代引用新生代的对象，导致一次Minor GC要额外遍历整个老年代，反之亦然。而为了避免把整个老年代加入GC Roots进行扫描，要使用**记忆集**。

​	**记忆集**的定义：记忆集是一种用于记录从**非收集区域指向收集区域**的指针集合的**抽象**数据结构。抽象意味着它只是一个**定义**，而没有说明实现方式。而其中一种实现方式是**卡表**。

> 记忆集的精度
>
> **字长精度**：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 
>
> **对象精度**：每个记录精确到一个对象，该对象里有字段含有跨代指针。 
>
> **卡精度**：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

​	第三种“卡精度”所指的是用一种称为“卡表”的方式去实现记忆集。

```c++
//卡表数组的结构
//这个实现将地址右移9位，即一个卡页的大小为2^9字节
CARD_TABLE [this address >> 9] = 0;
```

​	字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作**卡页**。

​	一个**卡页**的内存中通常包含不止一个对象，只要卡页内至少有一个对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，没有则标识为0。只要筛选出卡表中变脏的元素，就能得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

##### 写屏障

​	由于只有在**其他分带引用了待清理分带**内的对象时，卡页才会变脏。这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一 个赋值操作之中。

​	在HotSpot虚拟机里是通过写屏障技术维护卡表状态的。写屏障类似于AOP中的切面，而一般都是在**写后屏障（Post-Write Barrier）**中对卡表进行更新，简单来说就是在有**跨代引用**改变的语句后，都自动加一句将对应卡表更新的语句。

**伪共享**

​	由于现代中央处理器的缓存系统中是以缓存行为单位存储的，而多个卡表可能都在同一个缓存行中，同时写入一个缓存行导致性能下降。

​	最简单的解决办法是在**写入前**判断当前页表是否已经脏了（在前面加一个if判断）。

> 在JDK 7之后，HotSpot虚拟机增加了一个新的参数`-XX：+UseCondCardMark`，用来决定是否开启卡表更新的条件判断

##### 并发的可达性分析

见 [#如果没有重新标记产生的问题](#并发的可达性分析)

#### 经典垃圾收集器

##### Seria收集器

![image-20201117114457175](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201117114457175.png)

- 使用一个线程去完成垃圾收集
- 优点
  - 简单高效
  - 适合运行在客户端下的虚拟机
  - 内存占用小
- 缺点
  - 要暂停用户线程

##### ParNew收集器

![image-20201117114508651](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201117114508651.png)

- ParNew收集器除了支持多线程**并行**收集之外，其他与Serial收集器相比并没有太多创新之处
- 并行与并发
  - **并行**描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于**等待状态**
  - **并发**描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程**都在运行**

##### Parallel Scavenge收集器

- 基于标记-复制算法
- 目标是达到一个可控制的**吞吐量**

$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾搜集时间}
$$

##### Serial Old收集器

![image-20201120084853671](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120084853671.png)

- Serial的老年代版本

- 使用标记整理算法

##### Parallel Old收集器

![image-20201120090101325](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120090101325.png)

- Parallel Old是Parallel Scavenge收集器的老年代版本
- 支持多线程并发收集
- 基于标记-整理算法实

##### CMS收集器

![image-20201120090230703](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20201120090230703.png)

- 概念
  - Minor GC（新生代）
  - Major GC（老年代）
  - Full GC（整个Java堆）
  - CMS只能执行其中一种GC
- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- 基于标记-清除算法
- 收集分为四个部分
  - 初始标记(要暂停用户线程)
  - 并发标记
  - 重新标记(要暂停用户线程)
  - 并发清除
- 四个部分的作用
  - 初始标记用来**标记GC Roots**能直接关联到的对象
  - 并发标记是从GC Roots直接关联对象遍历整个对象图
  - 重新标记是为了修正并发期间的数据不一致
  - 并发清除是清除掉标记阶段被判断成死亡的对象
- 缺点
  - 无法处理"浮动垃圾"，即在并发标记和并发清理生成的垃圾
  - 因为在并发的时候用户线程还在运行，所以CMS不能等到老年代几乎满了才进行搜集。
  - 要预留空间，不然会出现"并发失败"，要暂停用户线程，并临时使用Serial Old来收集
  - 因为是标记清除算法，会产生很多碎片，触发一次Full GC，**而Full GC要暂停用户线**程

**<a id="并发的可达性分析">如果没有重新标记产生的问题</a>**

> **白色**：表示对象尚未被垃圾收集器访问过。。 
>
> **黑色**：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。
> **灰色**：表示对象已经被垃圾收集器访问过，但这个对象上**至少存在一个**引用还没有被扫描过。

**问题的产生**

![image-20210408161404679](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210408161404679.png)

<center>初始状态</center>

![image-20210408161437842](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210408161437842.png)

<center>扫描过程中状态改变</center>

​	状态的改变是左边黑点加上了对下面白点的引用，之后把右边灰点的引用删除。

​	可以看到，因为左边黑点已经被扫描了，所以之后不会被扫描。而右边灰点在进行扫描之前，把引用删除，所以之后的也不会扫描到下面这个点。最后导致下面这个点被错误标记为不可达。

>对象消失的两个条件
>
>- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
>- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

**解决方法**

- 增量更新

  - 破坏第一条件，即记录添加的
  - 当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来
  - 等并发扫描结束之后，将这些记录过的引用关系中的黑色对象为根，重新扫描一次

- 原始快照

  - 破坏第二个条件，即记录删除的
  - 当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用**记录下来**
  - 在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描

  CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现

##### Garbage First(G1) 收集器

> 它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量

![image-20210406114807671](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210406114807671.png)

- 可以执行Mixed GC（不用决定是面向新生代，老年代还是Java堆）
- 将内存空间分为很多相等大小的区域（Region），每个Region既可以是新生代也可以是老年代。
- Region中还有一类特殊的Humongous区域，专门用来存储大对象。如果对象超出一个Region的大小，会被存放在N个连续的Humongous Region中。
- 收集分为四个部分
  - 初始标记(要暂停用户线程)
  - 并发标记
  - 最终标记(要暂停用户线程)
  - 筛选回收(要暂停用户线程)
- 四个部分的作用
  - 暂停用户线程，标记GC Roots能直接关联到的对象
  - 并发的进行可达性分析
  - 暂停用户线程，处理并发阶段结束后仍遗留下来的最后那少量的SATB记录（**原始快照**中被记录的点）
  - 暂停用户线程，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。然后把决定回收的那一部分Region的**存活对象复制**到空的Region中，再清理掉整个旧Region的全部空间

**为什么筛选回收阶段也要暂停用户线程**

- 实现麻烦
- 不仅追求低延迟，还要保证**吞吐量**
- 后面也有低延迟的实现 - ZGC

#### 低延迟垃圾收集算法

- 低延迟收集算法主要追求的是停顿时间可控
- 所以总的收集时间可能会比其他收集器长

##### Shenandoah收集器

- 使用“连接矩阵”来代替记忆集。

- 因为没有分带，所有连接矩阵记录的是跨Region的引用关系

**gc过程**

- 初始标记：标记GC Root，要暂停用户线程
- 并发标记
- 最终标记：用原始标记来保证正确，有一小段停顿
- 并发清理：清理**没有任何**存活对象的Region
- 并发回收：将Region中存活的对象**并发地**复制到**未被使用**的Region中。因为用户线程仍然会对移动的对象不断进行读写，导致指向对象的引用还是**旧的地址**。Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决
- 初始引用更新：有一小段停顿，设立这个阶段只是为了建立一个线程集合点，确保**所有**并发回收阶段中进行的收集器线程都**已完成**分配给它们的对象移动任务。
- 并发引用更新：引用更新。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。
- 最终引用更新：最后一次停顿，用来修正GC Roots中的引用。
- 并发清理：回收集中再无存活对象，清理回收集。

![image-20210415112817281](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210415112817281.png)

**转发指针 **

**原理**

- 在原有对象布局结构的最前面统一增加一个**新的引用字段**，在正常不处于并发移动的情况下，该引用**指向对象自己**

![image-20210417164041889](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210417164041889.png)

- 当对象有拷贝时，只要修改这个指针即可完成指针转发。具体实现是将旧对象内的引用字段由指向自己修改到指向**拷贝对象**的地址

**多线程竞争**

- 使用CAS保证并发的正确性

##### ZGC收集器

> ZGC收集器是一款基于Region内存布局的，**（暂时） 不设分代**的，使用了**读屏障**、染色指针和**内存多重映射**等技术来实现可并发的**标记-整理**算法的，以低	延迟为首要目标的一款垃圾收集器

**内存布局**

- 小型Region：2MB，用于存放小于256KB的对象
- 中型Region：32MB，用于存放256KB~4MB的对象
- 大型Region：大小不固定，一个大型Region**只能存放一个对象**，不会被**重分配**

**指针染色技术**

> ​	从前，如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，通常会在对象头中**增加额外的存储字段**，如对象的哈希码、分代年龄、锁记录等就是这样存储的。但如果对象**存在被移动过的可能性**，即**不能保证对象访问**能够成功呢？ 又或者有一些根本就不会去访问对象，但又希望得知该对象的某些信息的应用场景呢？能不能**从指针或者与对象内存无关的地方得到这些信息**，譬如是否能够看出来对象被移动过?
>
> ​	ZGC的染色指针是最直接的、最纯粹的，它直接把**标记信息记在引用对象的指针**上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。

- 从**指针中**拿出高四位来作为标志位
  - 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region**立即就能够被释放和重用**
    **掉**，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。
  - 由于多使用了4位为标志位，导致4TB的内存限制。
  - 不能在32位平台使用

![image-20210509201508645](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210509201508645.png)

<center>染色指针示意</center>

- 为什么高18位不能使用？

> 实际上，基于需求、性能和成本的考虑，在AMD64架构中**只支持到52位**（4PB）的地址总线和**48位**（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持**47位（128TB）的进程虚拟地址空间**和**46位（64TB）的物理地址空间**，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。

**ZGC清理过程**

![image-20210509204709328](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210509204709328.png)

- 并发标记（Concurrent Mark）
  - 与G1、Shenandoah类似，但是是**直接在指针**上进行的，而不是对象
  - 标记阶段会更新染色指针中的**Marked 0、Marked 1**标志位
- 并发预备重分配（Concurrent Prepare for Relocate）
  - 统计出本次收集过程**要清理哪些Region**
  - ZGC每次回收都会扫描**所有**的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本
  - ZGC的**重分配集**只是决定了里面的存活对象会被重新复制到其他的Region中，**而并不能说回收行为就只是针对这个集合里面的Region进行**
- 并发重分配（Concurrent Relocate）
  - 这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个**转发表**
  - ZGC收集器能**仅从引用**上就得知一个对象是否处于重分配集之中
  - 由于[指针自愈](#指针自愈)，只有**第一次**访问旧对象会陷入转发，而且只要某个Region分配完成后，就可以**立即释放**用于新对象的分配，但是还要**保存转发表**。
- 并发重映射（Concurrent Remap）
  - 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用
  - 但ZGC的**并发重映射**并不是一个必须要“迫切”去完成的任务。因为**指针自愈**，重映射之前只是多了一次**转发**和**修正**，而不会占用多余的内存。
  - 所以ZGC地并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，节省了一次遍历对象图的开销。
  - 一旦所有指针都被修正之后，原来记录新旧 对象关系的转发表就可以释放掉了。

**<a id="指针自愈">指针自愈</a>**

**比较传统GC和ZGC**

- 对象状态
  - 传统GC：想要知道对象的状态，仅仅依靠指针是不行的，所以要通过指针访问对象
  - ZGC：由于在指针有标记位，所以无需访问对象就可以知道对象知否被移动，是否要转发等等。
- 回收Region
  - 传统GC（如Shenandoah）：在并发回收的时候，转发需要知道**Brooks Pointer**，而由于**Brooks Pointer**保存在对象头中，**所以在并发索引更新完成之前，是不能将某个完成回收的的对象清理掉**。
  - ZGC：由于在指针有标记位，只要知道指针就可以知道是否要转发，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其**直接指向新对象**，所以只有第一次访问旧对象会陷入转发，也就是**只慢一次**。而在**某个Region完成重分配后，就可以释放空间**，因为仅仅通过指针就可以知道对象是否要转发，通过转发表就知道要转发到哪里，而不要知道对象的具体信息。

## 虚拟机执行子系统

### 类文件结构

#### Class类文件的结构

> - 无符号数：**属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串
>   值。
> - 表：**是由多个无符号数或者其他表作为数据项构成的复合数据类型**，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表

| 类型           | 名称                | 数量                  |
| -------------- | ------------------- | --------------------- |
| u4             | magic               | 1                     |
| u2             | minor_version       | 1                     |
| u2             | major_version       | 1                     |
| u2             | constant_pool_count | 1                     |
| cp_info        | constant_pool       | constant_pool_count-1 |
| u2             | access_flags        | 1                     |
| u2             | this_class          | 1                     |
| u2             | super_class         | 1                     |
| u2             | interfaces_count    | 1                     |
| u2             | interfaces          | interfaces_count      |
| u2             | fields_count        | 1                     |
| field_info     | fields              | fields_count          |
| u2             | methods_count       | 1                     |
| method_info    | methods             | methods_count         |
| u2             | attributes_count    | 1                     |
| attribute_info | attributes          | attributes_count      |

<center>Class文件格式</center>

##### 结构示例

- jdk版本：openjdk 15.0.2 2021-01-19
- 编译代码：

```java
public class TestClass {
    private int m;
    public int inc() {
        return m + 1;
    }
}
```

- Class文件：

![image-20210510114508658](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210510114508658.png)

**magic**

![image-20210510112839729](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210510112839729.png)

- 长度：4字节

- 作用：魔数，用来标识当前文件是一个可以被虚拟机接受的文件。很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如GIF或者JPEG等在文件头中都存有魔数

**minor_version**

- 长度：2字节
- 作用：标识Class文件**次版本号**。在一段时间内废弃，现在通过设置为65535来标识为启用了预览功能的Class文件

**major_version**

![image-20210510113453182](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210510113453182.png)

- 长度：2字节
- 作用：标识Class文件**主版本号**。当前使用jdk15，Class文件版本号为59（00 00 00 3B）

**constant_pool_count**